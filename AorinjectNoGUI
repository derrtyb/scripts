getgenv().ballistics = 0.35
getgenv().PredictionState = true
getgenv().CamUndergroundResolver = true
getgenv().UnlockWhenPlayerDies = true
getgenv().CamlockPriority = false
getgenv().loaded = true

Drawing = Drawing
mousemoverel = mousemoverel

local Settings = {
    Head = "HumanoidRootPart",
    Humanoid = "Humanoid",
    NeckOffSet = Vector3.new(0, tonumber(getgenv().ballistics), 0)
};

local Locking = false
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local CurrentCamera = Workspace.CurrentCamera
local Drawingnew, Color3fromRGB, Vector2new = Drawing.new
local Color3fromRGB = Color3.fromRGB
local Vector2new = Vector2.new
local GetGuiInset = GuiService.GetGuiInset
local CharacterAdded = LocalPlayer.CharacterAdded
local CharacterAddedWait = CharacterAdded.Wait
local WorldToViewportPoint = CurrentCamera.WorldToViewportPoint
local RaycastParamsnew = RaycastParams.new
local EnumRaycastFilterTypeBlacklist = Enum.RaycastFilterType.Blacklist
local Raycast = Workspace.Raycast
local GetPlayers = Players.GetPlayers
local Instancenew = Instance.new
local IsDescendantOf = Instancenew("Part").IsDescendantOf
local FindFirstChildWhichIsA = Instancenew("Part").FindFirstChildWhichIsA
local FindFirstChild = Instancenew("Part").FindFirstChild
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera
local Enemy
local Render_Lock = nil
local FOV_Circle = Drawing.new("Circle")
FOV_Circle.Filled = false
FOV_Circle.Color = Color3.fromRGB(170, 255, 255)
FOV_Circle.Radius = getgenv().Aori.Camlock.FOVSize
FOV_Circle.Thickness = 1
FOV_Circle.Visible = false
FOV_Circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
local Move_Circle = nil
local accomidationfactor = 0.1
local aori, aoricammisc, aorisilmisc = nil, nil, nil
local antilockdetected = nil



getgenv().Aorinject = {
    Enabled = true,
    FOVSides = 25,
    FOVColour = Color3fromRGB(255, 255, 255),
    VisibleCheck = true,
    HitChance = 100,
    Selected = nil,
    SelectedPart = nil,
    TargetPart = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftLowerLeg",  "LeftUpperLeg", "RightLowerLeg", "RightUpperLeg"},
}


local circle = Drawingnew("Circle")
circle.Transparency = 0.4
circle.Thickness = 0.8
circle.Color = Aorinject.FOVColour
circle.Filled = false
Aorinject.FOVCircle = circle

function Aorinject.UpdateFOV()
    if not (circle) then
        return
    end
    circle.Visible = getgenv().Aori.Silent.ShowFOV
    circle.Radius = getgenv().Aori.Silent.FOVSize
    circle.Position = Vector2new(Mouse.X, Mouse.Y + GetGuiInset(GuiService).Y)
    circle.NumSides = Aorinject.FOVSides
    circle.Color = Aorinject.FOVColour
    return circle
end

function Aorinject.IsPartVisible(Part, PartDescendant)
    local Character = LocalPlayer.Character or CharacterAddedWait(CharacterAdded)
    local Origin = CurrentCamera.CFrame.Position
    local _, OnScreen = WorldToViewportPoint(CurrentCamera, Part.Position)
    if (OnScreen) then
        local raycastParams = RaycastParamsnew()
        raycastParams.FilterType = EnumRaycastFilterTypeBlacklist
        raycastParams.FilterDescendantsInstances = {Character, CurrentCamera}
        local Result = Raycast(Workspace, Origin, Part.Position - Origin, raycastParams)
        if (Result) then
            local PartHit = Result.Instance
            local Visible = (not PartHit or IsDescendantOf(PartHit, PartDescendant))
            return Visible
        end
    end
    return false
end

function Aorinject.Raycast(Origin, Destination, UnitMultiplier)
    if (typeof(Origin) == "Vector3" and typeof(Destination) == "Vector3") then
        if (not UnitMultiplier) then UnitMultiplier = 1 end
        local Direction = (Destination - Origin).Unit * UnitMultiplier
        local Result = Raycast(Workspace, Origin, Direction)
        if (Result) then
            local Normal = Result.Normal
            local Material = Result.Material
            return Direction, Normal, Material
        end
    end
    return nil
end

function Aorinject.Character(Player)
    return Player.Character
end

function Aorinject.CheckHealth(Player)
    local Character = Aorinject.Character(Player)
    local Humanoid = FindFirstChildWhichIsA(Character, "Humanoid")
    local Health = (Humanoid and Humanoid.Health or 0)
    return Health > 0
end

function Aorinject.Check()
    return (Aorinject.Enabled == true and Aorinject.Selected ~= LocalPlayer and Aorinject.SelectedPart ~= nil)
end
Aorinject.checkSilentAim = Aorinject.Check

function Aorinject.GetClosestTargetPartToCursor(Character)
    local TargetParts = Aorinject.TargetPart

    local ClosestPart = nil
    local ClosestPartPosition = nil
    local ClosestPartOnScreen = false
    local ClosestPartMagnitudeFromMouse = nil
    local ShortestDistance = 1/0
    local function CheckTargetPart(TargetPart)
        if (typeof(TargetPart) == "string") then
            TargetPart = FindFirstChild(Character, TargetPart)
        end
        if not (TargetPart) then
            return
        end
        local PartPos, onScreen = WorldToViewportPoint(CurrentCamera, TargetPart.Position)
        local GuiInset = GetGuiInset(GuiService)
        local Magnitude = (Vector2new(PartPos.X, PartPos.Y - GuiInset.Y) - Vector2new(Mouse.X, Mouse.Y)).Magnitude
        if (Magnitude < ShortestDistance) then
            ClosestPart = TargetPart
            ClosestPartPosition = PartPos
            ClosestPartOnScreen = onScreen
            ClosestPartMagnitudeFromMouse = Magnitude
            ShortestDistance = Magnitude
        end
    end
    if (typeof(TargetParts) == "string") then
        if (TargetParts == "All") then
            for _, v in ipairs(Character:GetChildren()) do
                if not (v:IsA("BasePart")) then
                    continue
                end
                CheckTargetPart(v)
            end
        else
            CheckTargetPart(TargetParts)
        end
    end
    if (typeof(TargetParts) == "table") then
        for _, TargetPartName in ipairs(TargetParts) do
            CheckTargetPart(TargetPartName)
        end
    end
    return ClosestPart, ClosestPartPosition, ClosestPartOnScreen, ClosestPartMagnitudeFromMouse
end

function Aorinject.GetClosestPlayerToCursor()
    local TargetPart = nil
    local ClosestPlayer = nil
    local ShortestDistance = 1/0
    for _, Player in ipairs(GetPlayers(Players)) do
        local Character = Aorinject.Character(Player)
        if Character then
            local TargetPartTemp, _, _, Magnitude = Aorinject.GetClosestTargetPartToCursor(Character)
            if (TargetPartTemp and Aorinject.CheckHealth(Player)) then
                if (circle.Radius > Magnitude and Magnitude < ShortestDistance) then
                    if (Aorinject.VisibleCheck and not Aorinject.IsPartVisible(TargetPartTemp, Character)) then continue end
                    ClosestPlayer = Player
                    ShortestDistance = Magnitude
                    TargetPart = TargetPartTemp
                end
            end
        end
    end

    Aorinject.Selected = ClosestPlayer
    Aorinject.SelectedPart = TargetPart
end

Heartbeat:Connect(function()
    Aorinject.UpdateFOV()
    Aorinject.GetClosestPlayerToCursor()
    
    --[[if Aorinject.Selected and Aorinject.Selected ~= game.Players.LocalPlayer and Aorinject.Selected.Character:WaitForChild("BodyEffects")["K.O"].Value == false and Aorinject.Selected.Character:FindFirstChild("GRABBING_CONSTRAINT") == false then
        Aorinject.SelectedPart.Velocity = Vector3.new(Aorinject.SelectedPart.Velocity.X, math.clamp(Aorinject.SelectedPart.Velocity.Y, 0, 50), Aorinject.SelectedPart.Velocity.Z)
        Aorinject.SelectedPart.AssemblyLinearVelocity = Vector3.new(Aorinject.SelectedPart.Velocity.X, math.clamp(Aorinject.SelectedPart.Velocity.Y, 0, 50), Aorinject.SelectedPart.Velocity.Z)
    end--]]

    if Locking and Enemy ~= nil and getgenv().Aori.CamLegit.Shake then
        mousemoverel(math.random(-getgenv().Aori.CamLegit.ShakePower, getgenv().Aori.CamLegit.ShakePower), (math.random(-getgenv().Aori.CamLegit.ShakePower, getgenv().Aori.CamLegit.ShakePower)) * 0.5)
        wait(5)
    end

    if getgenv().Aori.Legit.Humanize then
        local SilVel = Aorinject.Selected.Character.HumanoidRootPart
        SilVel.Velocity = Vector3.new(SilVel.Velocity.X, SilVel.Velocity.Y, SilVel.Velocity.Z) + 
        Vector3.new(math.random(-getgenv().Aori.Legit.HumanizePower, getgenv().Aori.Legit.HumanizePower), math.random(-getgenv().Aori.Legit.HumanizePower, getgenv().Aori.Legit.HumanizePower), math.random(-getgenv().Aori.Legit.HumanizePower, getgenv().Aori.Legit.HumanizePower)) * 0.1
    end

    if FOV_Circle.Visible == false and Aori.Camlock.ShowFOV == true then
        FOV_Circle.Visible = true
    elseif FOV_Circle.Visible == true and Aori.Camlock.ShowFOV == false then
        FOV_Circle.Visible = false
    end

    --// anti macro fling
    if LocalPlayer.Character.Humanoid:GetStateEnabled(Enum.HumanoidStateType.FallingDown) then
        LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    end

end)

local lplr = game.Players.LocalPlayer
local resolver
local AoriHRP
local AoriCamHRP

local function AddResolver()
    pcall(function()
        AoriHRP = Aorinject.Selected.Character.HumanoidRootPart
        AoriHRP.Velocity = Vector3.new(AoriHRP.Velocity.X, math.clamp(AoriHRP.Velocity.Y, 0, 50), AoriHRP.Velocity.Z)
        if Locking and antilockdetected then
            AoriCamHRP = Enemy.HumanoidRootPart
            AoriCamHRP.Velocity = Vector3.new(0, 0, 0)
            AoriCamHRP.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
    end)
end

resolver = Heartbeat:Connect(AddResolver)

--// executes resolver again on respawn

task.spawn(function()
	lplr.CharacterAdded:Connect(function()
		resolver:Disconnect()
		wait(5)
		resolver = Heartbeat:Connect(AddResolver)
	end)
end)


Move_Circle = RunService.RenderStepped:Connect(function()
    FOV_Circle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
end)

function InRadius()
    local Target = nil
    local Distance = 9e9
    local Camera = game:GetService("Workspace").CurrentCamera
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character[Settings.Head] and v.Character[Settings.Humanoid] and v.Character.BodyEffects['K.O'].Value == false and
            v.Character[Settings.Humanoid].Health > 0 then
            local Enemy = v.Character
            local CastingFrom = CFrame.new(Camera.CFrame.Position, Enemy[Settings.Head].CFrame.Position) *
                                    CFrame.new(0, 0, -4)
            local RayCast = Ray.new(CastingFrom.Position, CastingFrom.LookVector * 9000)
            local World, ToSpace = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(RayCast,
                {LocalPlayer.Character[Settings.Head]});
            local RootWorld = (Enemy[Settings.Head].CFrame.Position - ToSpace).magnitude
            if RootWorld < 4 then
                local RootPartPosition, Visible = Camera:WorldToViewportPoint(Enemy[Settings.Head].Position)
                if Visible then
                    local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) -
                                               Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                    if Real_Magnitude < Distance and Real_Magnitude < getgenv().Aori.Camlock.FOVSize then
                        Distance = Real_Magnitude
                        Target = Enemy
                    end
                end
            end
        end
    end
    return Target
end
function Aorinject.Check()
    if not (Aorinject.Enabled == true and Aorinject.Selected ~= LocalPlayer and Aorinject.SelectedPart ~= nil) then
        return false
    end
    local Character = Aorinject.Character(Aorinject.Selected)
    local KOd = Character:WaitForChild("BodyEffects")["K.O"].Value
    local Grabbed = Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    if getgenv().Aori.Silent.GrabbedCheck then
        if Grabbed then
            return false
        end
    end
    if getgenv().Aori.Silent.KOCheck then
        if KOd then
            return false
        end
    end
    if getgenv().Aori.Legit.UnlockWhenAntiDetected then
        if math.abs(Aorinject.Selected.Character.HumanoidRootPart.Velocity.X) > getgenv().Aori.Legit.VelocityDetectionAmount or Aorinject.Selected.Character.HumanoidRootPart.Velocity.Y > getgenv().Aori.Legit.VelocityDetectionAmount or math.abs(Aorinject.Selected.Character.HumanoidRootPart.Velocity.Z) > getgenv().Aori.Legit.VelocityDetectionAmount then
            return false
        end
    end
    return true
end
function Aimbot()
    pcall(function()
        if Locking then
            local Camera = game:GetService("Workspace").CurrentCamera
            local Predicted_Position = nil
            local GetPositionsFromVector3 = nil
            local Distance = 9e9
            if Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health > 0 and
            getgenv().Aori.Camlock.Smoothness and getgenv().PredictionState then
                Render_Lock = RunService.Stepped:Connect(function()
                    pcall(function()
                        if getgenv().Aori.CamLegit.UnlockOutsideFOVRadius then
                            local RootPartPosition = Camera:WorldToViewportPoint(Enemy[Settings.Head].Position)
                            local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) -
                                                       Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                            if Real_Magnitude < Distance and Real_Magnitude < getgenv().Aori.Camlock.FOVSize then
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 and getgenv().CamUndergroundResolver then
                                    local hrp = Enemy.HumanoidRootPart
                                    hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                                end
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 then
                                    Predicted_Position = Enemy[Settings.Head].Position +
                                                             (Enemy[Settings.Head].AssemblyLinearVelocity *
                                                             getgenv().Aori.Camlock.Prediction + Settings.NeckOffSet)
                                    GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                    mousemoverel((GetPositionsFromVector3.X - Mouse.X) / getgenv().Aori.Camlock.SmoothnessAmount,
                                        (GetPositionsFromVector3.Y - Mouse.Y) / getgenv().Aori.Camlock.SmoothnessAmount)
                                elseif Locking == false then
                                    Enemy = nil
                                elseif Enemy == nil then
                                    Locking = false
                                end
                            end
                        elseif getgenv().Aori.CamLegit.UnlockOutsideFOVRadius == false then
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 and getgenv().CamUndergroundResolver then
                                local hrp = Enemy.HumanoidRootPart
                                hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                            end
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 then
                                Predicted_Position = Enemy[Settings.Head].Position +
                                                         (Enemy[Settings.Head].AssemblyLinearVelocity *
                                                         getgenv().Aori.Camlock.Prediction + Settings.NeckOffSet)
                                GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                mousemoverel((GetPositionsFromVector3.X - Mouse.X) / getgenv().Aori.Camlock.SmoothnessAmount,
                                    (GetPositionsFromVector3.Y - Mouse.Y) / getgenv().Aori.Camlock.SmoothnessAmount)
                            elseif Locking == false then
                                Enemy = nil
                            elseif Enemy == nil then
                                Locking = false
                            end
                        end
                    end)
                end)
            elseif Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health > 0 and
            getgenv().Aori.Camlock.Smoothness == false and getgenv().PredictionState then
                Render_Lock = RunService.Stepped:Connect(function()
                    pcall(function()
                        if getgenv().Aori.CamLegit.UnlockOutsideFOVRadius then
                            local RootPartPosition = Camera:WorldToViewportPoint(Enemy[Settings.Head].Position)
                            local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) -
                                                       Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                            if Real_Magnitude < Distance and Real_Magnitude < getgenv().Aori.Camlock.FOVSize then
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 and getgenv().CamUndergroundResolver then
                                    local hrp = Enemy.HumanoidRootPart
                                    hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                                end
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 then
                                    Predicted_Position = Enemy[Settings.Head].Position +
                                                             (Enemy[Settings.Head].AssemblyLinearVelocity *
                                                             getgenv().Aori.Camlock.Prediction + Settings.NeckOffSet)
                                    GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                    mousemoverel((GetPositionsFromVector3.X - Mouse.X) / 0.55,
                                        (GetPositionsFromVector3.Y - Mouse.Y) / 0.55)
                                elseif Locking == false then
                                    Enemy = nil
                                elseif Enemy == nil then
                                    Locking = false
                                end
                            end
                        elseif getgenv().Aori.CamLegit.UnlockOutsideFOVRadius == false then
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 and getgenv().CamUndergroundResolver then
                                local hrp = Enemy.HumanoidRootPart
                                hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                            end
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 then
                                Predicted_Position = Enemy[Settings.Head].Position +
                                                         (Enemy[Settings.Head].AssemblyLinearVelocity *
                                                         getgenv().Aori.Camlock.Prediction + Settings.NeckOffSet)
                                GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                mousemoverel((GetPositionsFromVector3.X - Mouse.X) / 0.55,
                                    (GetPositionsFromVector3.Y - Mouse.Y) / 0.55)
                            elseif Locking == false then
                                Enemy = nil
                            elseif Enemy == nil then
                                Locking = false
                            end
                        end
                    end)
                end)
            elseif Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health > 0 and
            getgenv().Aori.Camlock.Smoothness and getgenv().PredictionState == false then
                Render_Lock = RunService.Stepped:Connect(function()
                    pcall(function()
                        if getgenv().Aori.CamLegit.UnlockOutsideFOVRadius then
                            local RootPartPosition = Camera:WorldToViewportPoint(Enemy[Settings.Head].Position)
                            local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) -
                                                       Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                            if Real_Magnitude < Distance and Real_Magnitude < getgenv().Aori.Camlock.FOVSize then
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 and getgenv().CamUndergroundResolver then
                                    local hrp = Enemy.HumanoidRootPart
                                    hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                                end
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 then
                                    Predicted_Position = Enemy[Settings.Head].Position
                                    GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                    mousemoverel((GetPositionsFromVector3.X - Mouse.X) / getgenv().Aori.Camlock.SmoothnessAmount,
                                        (GetPositionsFromVector3.Y - Mouse.Y) / getgenv().Aori.Camlock.SmoothnessAmount)
                                elseif Locking == false then
                                    Enemy = nil
                                elseif Enemy == nil then
                                    Locking = false
                                end
                            end
                        elseif getgenv().Aori.CamLegit.UnlockOutsideFOVRadius == false then
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 and getgenv().CamUndergroundResolver then
                                local hrp = Enemy.HumanoidRootPart
                                hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                            end
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 then
                                Predicted_Position = Enemy[Settings.Head].Position
                                GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                mousemoverel((GetPositionsFromVector3.X - Mouse.X) / getgenv().Aori.Camlock.SmoothnessAmount,
                                    (GetPositionsFromVector3.Y - Mouse.Y) / getgenv().Aori.Camlock.SmoothnessAmount)
                            elseif Locking == false then
                                Enemy = nil
                            elseif Enemy == nil then
                                Locking = false
                            end
                        end
                    end)
                end)
            elseif Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health > 0 and
            getgenv().Aori.Camlock.Smoothness == false and getgenv().PredictionState == false then
                Render_Lock = RunService.Stepped:Connect(function()
                    pcall(function()
                        if getgenv().Aori.CamLegit.UnlockOutsideFOVRadius then
                            local RootPartPosition = Camera:WorldToViewportPoint(Enemy[Settings.Head].Position)
                            local Real_Magnitude = (Vector2.new(Mouse.X, Mouse.Y) -
                                                       Vector2.new(RootPartPosition.X, RootPartPosition.Y)).Magnitude
                            if Real_Magnitude < Distance and Real_Magnitude < getgenv().Aori.Camlock.FOVSize then
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 and getgenv().CamUndergroundResolver then
                                    local hrp = Enemy.HumanoidRootPart
                                    hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                                end
                                if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and
                                    Enemy[Settings.Humanoid].Health > 0 then
                                    Predicted_Position = Enemy[Settings.Head].Position
                                    GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                    mousemoverel((GetPositionsFromVector3.X - Mouse.X) / 0.6,
                                        (GetPositionsFromVector3.Y - Mouse.Y) / 0.6)
                                elseif Locking == false then
                                    Enemy = nil
                                elseif Enemy == nil then
                                    Locking = false
                                end
                            end
                        elseif getgenv().Aori.CamLegit.UnlockOutsideFOVRadius == false then
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 and getgenv().CamUndergroundResolver then
                                local hrp = Enemy.HumanoidRootPart
                                hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
                            end
                            if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] and Enemy[Settings.Humanoid].Health >
                                0 then
                                Predicted_Position = Enemy[Settings.Head].Position
                                GetPositionsFromVector3 = Camera:WorldToScreenPoint(Predicted_Position)
                                mousemoverel((GetPositionsFromVector3.X - Mouse.X) / 0.6,
                                    (GetPositionsFromVector3.Y - Mouse.Y) / 0.6)
                            elseif Locking == false then
                                Enemy = nil
                            elseif Enemy == nil then
                                Locking = false
                            end
                        end
                    end)
                end)
            end
        end
    end)
end

RunService.Stepped:Connect(function()
    if Locking and Enemy ~= nil then
        if Enemy.HumanoidRootPart.Velocity.Y > 1 then
            Settings.Head = "Head"
        elseif Settings.Head == "Head" and Enemy.HumanoidRootPart.Velocity.Y < 1 then
            Settings.Head = "HumanoidRootPart"
        end
    end
    if Locking and getgenv().Aori.Camlock.AutoDesyncResolver then
        if math.abs(Enemy.HumanoidRootPart.Velocity.X) > 49 or Enemy.HumanoidRootPart.Velocity.Y > 49 or math.abs(Enemy.HumanoidRootPart.Velocity.Z) > 49 or math.abs(Aorinject.Selected.Character.HumanoidRootPart.Velocity.X) > getgenv().Aori.Legit.VelocityDetectionAmount or Aorinject.Selected.Character.HumanoidRootPart.Velocity.Y > getgenv().Aori.Legit.VelocityDetectionAmount or math.abs(Aorinject.Selected.Character.HumanoidRootPart.Velocity.Z) > getgenv().Aori.Legit.VelocityDetectionAmount then
            antilockdetected = true
        else
            antilockdetected = false
        end
    end
    if getgenv().Aori.Camlock.UnlockWhenTargetDies then
        if Locking and Enemy ~= nil and Enemy[Settings.Humanoid] then
            if Enemy.BodyEffects['K.O'].Value == true and Enemy[Settings.Humanoid] then
                Locking = false
                Render_Lock:Disconnect()
            end
        end
    end
    if getgenv().UnlockWhenPlayerDies then
        if game.Players.LocalPlayer.Character.BodyEffects['K.O'].Value == true or
            game.Players.LocalPlayer.Character.Humanoid.Health <= 0 then
            Locking = false
            Render_Lock:Disconnect()
        end
    end
end)



Mouse.KeyDown:Connect(function(KeyPressed)
    if KeyPressed == string.lower(getgenv().Aori.Silent.SilentKeybind) then
        pcall(function()
            if getgenv().Aori.Silent.Enabled == true then
                getgenv().Aori.Silent.Enabled = false
                silentaimstatus = "Disabled"
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Silent Aim",
                    Text = "OFF",
                    Duration = 1
                })
            elseif getgenv().Aori.Silent.Enabled == false then
                getgenv().Aori.Silent.Enabled = true
                silentaimstatus = "Enabled"
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Silent Aim",
                    Text = "ON",
                    Duration = 1
                })
            end
        end)
    end
    if KeyPressed == string.lower(getgenv().Aori.Camlock.CamlockKeybind) then
        pcall(function()
            if Locking == false then
                Locking = true
                Aimbot()
                Enemy = InRadius()
                if getgenv().Aori.Camlock.Notifications then
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "aorinject",
                        Text = "Target:  " .. tostring(Enemy.Humanoid.DisplayName .. ".")
                    })
                end
                if Enemy == nil then
                    Locking = false
                end
            elseif Locking == true then
                if getgenv().Aori.Camlock.Notifications then
                    game.StarterGui:SetCore("SendNotification", {
                        Title = "aorinject",
                        Text = "Unlocked."
                    })
                end
                Locking = false
                Render_Lock:Disconnect()
            end
        end)
    end
end)


--// esp section
local taffy = false
local noob = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer
local lol = LocalPlayer:GetMouse()

lol.KeyDown:Connect(function(aaa)
	if aaa == string.lower(getgenv().Aori.Esp.Keybind) then
		pcall(function()
			if taffy == false then
				taffy = true
				getgenv().taffyesp.box.enabled = true
                getgenv().taffyesp.box.outline = true
				getgenv().taffyesp.name.enabled = true
			elseif taffy == true then
				taffy = false
				getgenv().taffyesp.box.enabled = false
                getgenv().taffyesp.box.outline = false
				getgenv().taffyesp.name.enabled = false
			end
		end)
	end
end)


local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInput = game:GetService("UserInputService")

getgenv().taffyesp = {
    box = {
        enabled1 = true,
        enabled = false,
        outline = false,
        healthbar = false,
        color1 = Color3.fromRGB(0, 0, 0),
        color2 = Color3.fromRGB(255, 255, 255),
        healthbarcolor = Color3.fromRGB(0, 255, 0)
    },
    tracer = {
        enabled = false,
        unlocktracers = false,
        color = Color3.fromRGB(255, 255, 255)
    },
    name = {
        enabled = false,
        outline = false,
        size = 13,
        font = 2,
        color = Color3.fromRGB(255, 255, 255)
    },
    misc = {
        teamcheck = false,
        useteamcolors = false,
        visibleonly = true
    },
    Toolsshow = {
        enable = false,
        outline = false,
        size = 8,
        font = 3,
        color = Color3.fromRGB(147, 39, 161)
    }
}

function esp(v)
    -- box --
    local BLOCKOUTLINE = Drawing.new("Square")
    BLOCKOUTLINE.Visible = false
    BLOCKOUTLINE.Color = Color3.new(0,0,0)
    BLOCKOUTLINE.Thickness = 1
    BLOCKOUTLINE.Transparency = 1
    BLOCKOUTLINE.Filled = false

    local BOXPLAYER = Drawing.new("Square")
    BOXPLAYER.Visible = false
    BOXPLAYER.Color = taffyesp.box.color1
    BOXPLAYER.Thickness = 1
    BOXPLAYER.Transparency = 1
    BOXPLAYER.Filled = false

    local HealthBarOUTLINE = Drawing.new("Square")
    HealthBarOUTLINE.Thickness = 1
    HealthBarOUTLINE.Filled = false
    HealthBarOUTLINE.Color = Color3.new(0,0,0)
    HealthBarOUTLINE.Transparency = 1
    HealthBarOUTLINE.Visible = false

    local HealthBarITSELF = Drawing.new("Square")
    HealthBarITSELF.Thickness = 1
    HealthBarITSELF.Filled = false
    HealthBarITSELF.Transparency = 1
    HealthBarITSELF.Visible = false
    
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1,1,1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    local Name = Drawing.new("Text")
    Name.Transparency = 1
    Name.Visible = false
    Name.Color = taffyesp.name.color
    Name.Size = 16
    Name.Center = true
    Name.Outline = false
    Name.Font = 2
    Name.Text = "name [100/100]"

    local toolshow = Drawing.new("Text")
    toolshow.Transparency = 1
    toolshow.Visible = false
    toolshow.Color = getgenv().taffyesp.Toolsshow.color
    toolshow.Size = 16
    toolshow.Center = true
    toolshow.Outline = false
    toolshow.Font = 2
    toolshow.Text = ""
game:GetService("RunService").RenderStepped:Connect(function()
        if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health  > 0 and (not taffyesp.misc.teamcheck or v.TeamColor == lplr.TeamColor) then
            local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
            local Distance = (CurrentCamera.CFrame.p - v.Character.HumanoidRootPart.Position).Magnitude
            local RootPart = v.Character.HumanoidRootPart
            local Head = v.Character.Head
            local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
            local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + Vector3.new(0,0.5,0))
            local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - Vector3.new(0,3,0))
            if (not taffyesp.misc.visibleonly or onScreen) then
                if taffyesp.box.enabled1 then
                    BLOCKOUTLINE.Size = Vector2.new(2500 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BLOCKOUTLINE.Position = Vector2.new(RootPosition.X - BLOCKOUTLINE.Size.X / 2, RootPosition.Y - BLOCKOUTLINE.Size.Y / 2)
                    BLOCKOUTLINE.Visible = taffyesp.box.outline
                    BLOCKOUTLINE.Color = taffyesp.box.color2
    
                    BOXPLAYER.Size = Vector2.new(2500 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BOXPLAYER.Position = Vector2.new(RootPosition.X - BOXPLAYER.Size.X / 2, RootPosition.Y - BOXPLAYER.Size.Y / 2)
                    BOXPLAYER.Visible = taffyesp.box.enabled
                    if not taffyesp.misc.useteamcolors then
                        local color = v.TeamColor
                        BOXPLAYER.Color = taffyesp.box.color1
                    else
                        BOXPLAYER.Color = taffyesp.box.color1
                    end
                        
                    HealthBarOUTLINE.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                    HealthBarOUTLINE.Position = HealthBarOUTLINE.Position - Vector2.new(6,0)
                    HealthBarOUTLINE.Visible = taffyesp.box.outline
    
                    HealthBarITSELF.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (v.Character.Humanoid.MaxHealth / math.clamp(v.Character.Humanoid.Health, 0,v.Character.Humanoid.MaxHealth)))
                    HealthBarITSELF.Position = Vector2.new(BOXPLAYER.Position.X - 5, BOXPLAYER.Position.Y + (1 / HealthBarITSELF.Size.Y))
                    HealthBarITSELF.Color = taffyesp.box.healthbarcolor
                    HealthBarITSELF.Visible = taffyesp.box.healthbar
                    
                    
                    
                    
                else
                    BLOCKOUTLINE.Visible = false
                    BOXPLAYER.Visible = false
                    HealthBarOUTLINE.Visible = false
                    HealthBarITSELF.Visible = false
                end
                if taffyesp.tracer.enabled then
                    if taffyesp.tracer.unlocktracers then
                        Tracer.From = Vector2.new(mouse.X, mouse.Y + 36)
                    else
                        Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    end
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)
                    Tracer.Visible = taffyesp.tracer.enabled
                    if not taffyesp.misc.useteamcolors then
                        local color = v.TeamColor
                        Tracer.Color = taffyesp.tracer.color
                    else
                        Tracer.Color = taffyesp.tracer.color
                    end
                else
                    Tracer.Visible = false
                end

                if taffyesp.Toolsshow.enable then
                      local Equipped = v.Character:FindFirstChildOfClass("Tool") and v.Character:FindFirstChildOfClass("Tool").Name or ""
                    toolshow.Text = Equipped
                    toolshow.Position = Vector2.new(workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).X, workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).Y + 30)
                    toolshow.Color = getgenv().taffyesp.Toolsshow.color
                    toolshow.Font = 3
                    Name.Size = taffyesp.Toolsshow.size
                    toolshow.Visible = true
                    else
                        toolshow.Visible = false
                end


                if taffyesp.name.enabled then
                    Name.Text = tostring(v.Character.Humanoid.DisplayName).. " [" .. tostring(math.floor(v.Character.Humanoid.Health + 0.5)) .. "]"
                    Name.Position = Vector2.new(workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).X, workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).Y - 30)
                    Name.Visible = true
                    Name.Size = taffyesp.name.size
                    if not taffyesp.misc.useteamcolors then
                        local color = v.TeamColor
                        Name.Color = taffyesp.name.color
                    else
                        Name.Color = taffyesp.name.color
                    end
                    Name.Outline = taffyesp.name.outline
                else
                    Name.Visible = false
                end
            else
                BLOCKOUTLINE.Visible = false
                BOXPLAYER.Visible = false
                toolshow.Visible=false
                HealthBarOUTLINE.Visible = false
                HealthBarITSELF.Visible = false
                Tracer.Visible = false
                Name.Visible = false
            end
        else
            toolshow.Visible=false
            BLOCKOUTLINE.Visible = false
            BOXPLAYER.Visible = false
            HealthBarOUTLINE.Visible = false
            HealthBarITSELF.Visible = false
            Tracer.Visible = false
            Name.Visible = false
        end
    end)
end

for i,v in pairs(game.Players:GetChildren()) do
    esp(v)
end

game.Players.PlayerAdded:Connect(function(v)
    esp(v)
end)


local __index
__index = hookmetamethod(game, "__index", function(t, k)
    if (t:IsA("Mouse") and (k == "Hit" or k == "Target") and Aorinject.Check()) then
        local SelectedPart = Aorinject.SelectedPart
        if (getgenv().Aori.Silent.Enabled and (k == "Hit" or k == "Target")) then
            local Hit = SelectedPart.CFrame + (SelectedPart.Velocity * getgenv().Aori.Silent.Prediction)
            return (k == "Hit" and Hit or SelectedPart)
        end
    end
    return __index(t, k)
end)

