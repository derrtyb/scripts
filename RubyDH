repeat
    wait()
until game:IsLoaded()

game:GetService("CorePackages").Packages:Destroy()

local rubyLoader = Instance.new("ScreenGui")
local BackFrame = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local TopFrame = Instance.new("Frame")
local UICorner_2 = Instance.new("UICorner")
local UIGradient = Instance.new("UIGradient")
local TextLabel = Instance.new("TextLabel")
local UIGradient_2 = Instance.new("UIGradient")
local LoadingText = Instance.new("TextLabel")
local LoadingFrame = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local UIGradient_3 = Instance.new("UIGradient")
local Loading = Instance.new("Frame")
local UICorner_4 = Instance.new("UICorner")
local UIGradient_4 = Instance.new("UIGradient")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")

rubyLoader.Name = "rubyLoader"
rubyLoader.Parent = game.CoreGui
rubyLoader.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

BackFrame.Name = "BackFrame"
BackFrame.Parent = rubyLoader
BackFrame.AnchorPoint = Vector2.new(0.5, 0.5)
BackFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
BackFrame.Position = UDim2.new(0.493000001, 0, 1.07000005, 0)
BackFrame.Size = UDim2.new(0, 361, 0, 101)

UICorner.CornerRadius = UDim.new(0, 12)
UICorner.Parent = BackFrame

TopFrame.Name = "TopFrame"
TopFrame.Parent = BackFrame
TopFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TopFrame.Size = UDim2.new(0, 361, 0, 29)

UICorner_2.CornerRadius = UDim.new(0, 12)
UICorner_2.Parent = TopFrame

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(121, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(182, 0, 0))}
UIGradient.Rotation = 90
UIGradient.Parent = TopFrame

TextLabel.Parent = TopFrame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.387811601, 0, -0.0344827585, 0)
TextLabel.Size = UDim2.new(0, 87, 0, 29)
TextLabel.Font = Enum.Font.Code
TextLabel.Text = "Ruby"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(182, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(81, 0, 0))}
UIGradient_2.Offset = Vector2.new(0.5, 0)
UIGradient_2.Rotation = 90
UIGradient_2.Parent = BackFrame

LoadingText.Name = "LoadingText"
LoadingText.Parent = BackFrame
LoadingText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
LoadingText.BackgroundTransparency = 1.000
LoadingText.Position = UDim2.new(0.0775623247, 0, 0.286810249, 0)
LoadingText.Size = UDim2.new(0, 312, 0, 25)
LoadingText.Font = Enum.Font.Code
LoadingText.Text = "checking for updates.."
LoadingText.TextColor3 = Color3.fromRGB(163, 163, 163)
LoadingText.TextScaled = true
LoadingText.TextSize = 14.000
LoadingText.TextWrapped = true

LoadingFrame.Name = "LoadingFrame"
LoadingFrame.Parent = BackFrame
LoadingFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
LoadingFrame.Position = UDim2.new(0.0526315793, 0, 0.605504572, 0)
LoadingFrame.Size = UDim2.new(0, 321, 0, 26)

UICorner_3.CornerRadius = UDim.new(0, 12)
UICorner_3.Parent = LoadingFrame

UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(106, 106, 106)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(61, 61, 61))}
UIGradient_3.Rotation = 90
UIGradient_3.Parent = LoadingFrame

Loading.Name = "Loading"
Loading.Parent = LoadingFrame
Loading.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Loading.Position = UDim2.new(0, 0, -0.00988065265, 0)
Loading.Size = UDim2.new(0.0280373823, 0, 1.00988066, 0)

UICorner_4.CornerRadius = UDim.new(0, 12)
UICorner_4.Parent = Loading

UIGradient_4.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(220, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(115, 0, 0))}
UIGradient_4.Rotation = 90
UIGradient_4.Parent = Loading

UIAspectRatioConstraint.Parent = BackFrame
UIAspectRatioConstraint.AspectRatio = 3.574


local function TFOQWM_fake_script()
    local script = Instance.new('LocalScript', Loading)

    local LoadingTxt = script.Parent.Parent
    local goingDownxd = script.Parent.Parent.Parent.Parent.BackFrame
        local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
    wait(2)

    script.Parent:TweenSize(UDim2.new(0, 165,0, 26))
    script.Parent.Parent.Parent.LoadingText.Text = "bypassing anticheat"
    assert(getrawmetatable)
    grm = getrawmetatable(game)
    setreadonly(grm, false)
    old = grm.__namecall
    grm.__namecall = newcclosure(function(self, ...)
        local args = {...}
        if tostring(args[1]) == "TeleportDetect" then
            return
        elseif tostring(args[1]) == "CHECKER_1" then
            return
        elseif tostring(args[1]) == "CHECKER" then
            return
        elseif tostring(args[1]) == "GUI_CHECK" then
            return
        elseif tostring(args[1]) == "OneMoreTime" then
            return
        elseif tostring(args[1]) == "checkingSPEED" then
            return
        elseif tostring(args[1]) == "BANREMOTE" then
            return
        elseif tostring(args[1]) == "PERMAIDBAN" then
            return
        elseif tostring(args[1]) == "KICKREMOTE" then
            return
        elseif tostring(args[1]) == "BR_KICKPC" then
            return
        elseif tostring(args[1]) == "BR_KICKMOBILE" then
            return
        end
        return old(self, ...)
    end)
    print("[1/2] Bypassing Anticheat")
    local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()

    wait(1.5)
    script.Parent:TweenSize(UDim2.new(1,0,1,0))
    script.Parent.Parent.Parent.LoadingText.Text = "executing ui"
    print("[2/2] Executing ui in 2S")
        local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://3320590485"
sound.Parent = game:GetService("SoundService")
sound:Play()
    wait(2)
    goingDownxd:TweenPosition(UDim2.new(0.493, 0,1.07, 0))
    wait(1)
    script.Parent.Parent.Parent.Parent.Parent.rubyLoader:Destroy()
end
coroutine.wrap(TFOQWM_fake_script)()
local function DDIVBK_fake_script()
    local script = Instance.new('LocalScript', BackFrame)

    script.Parent:TweenPosition(UDim2.new(0.5, 0,0.499, 0))
end
coroutine.wrap(DDIVBK_fake_script)()

wait(8.8)

function CheckStatus(param)
    if param == "visualc0de" or "dhscripts1" or "l4ost" then
        return "Private"
    end
    return "Whitelisted"
end

function GetSubPrefix(str)
    local str = tostring(str):gsub(" ","")
    local var = ""
    --
    if #str == 2 then
        local sec = string.sub(str,#str,#str+1)
        var = sec == "1" and "st" or sec == "2" and "nd" or sec == "3" and "rd" or "th"
    end
    --
    return var
end

local title_string = "ruby | User Status : "..CheckStatus(game.Players.LocalPlayer.Name)


local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInput = game:GetService("UserInputService")

local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, Typing)
  if Typing then return end
  
end)

_G.FakeAnim1 = game.Players.LocalPlayer.Character.Animate.idle.Animation1.AnimationId
_G.FakeAnim2 = game.Players.LocalPlayer.Character.Animate.run.RunAnim.AnimationId
_G.FakeAnim3 = game.Players.LocalPlayer.Character.Animate.walk.WalkAnim.AnimationId


getgenv().taffy_esp = {
    box = {
        enabled1 = true,
        enabled = false,
        outline = false,
        healthbar = false,
        color1 = Color3.fromRGB(255, 255, 255),
        color2 = Color3.fromRGB(0, 0, 0),
        healthbarcolor = Color3.fromRGB(4, 0, 255)
    },
    tracer = {
        enabled = false,
        unlocktracers = false,
        color = Color3.fromRGB(255, 255, 255)
    },
    name = {
        enabled = false,
        outline = false,
        size = 13,
        font = 2,
        color = Color3.fromRGB(255, 255, 255)
    },
    misc = {
        teamcheck = false,
        useteamcolors = false,
        visibleonly = true
    },
    Toolsshow = {
        enable = false,
        outline = false,
        size = 8,
        font = 3,
        color = Color3.fromRGB(147, 39, 161)
    }
}

function esp(v)
    -- box --
    local BLOCKOUTLINE = Drawing.new("Square")
    BLOCKOUTLINE.Visible = false
    BLOCKOUTLINE.Color = Color3.new(0,0,0)
    BLOCKOUTLINE.Thickness = 3
    BLOCKOUTLINE.Transparency = 1
    BLOCKOUTLINE.Filled = false

    local BOXPLAYER = Drawing.new("Square")
    BOXPLAYER.Visible = false
    BOXPLAYER.Color = taffy_esp.box.color1
    BOXPLAYER.Thickness = 1
    BOXPLAYER.Transparency = 1
    BOXPLAYER.Filled = false

    local HealthBarOUTLINE = Drawing.new("Square")
    HealthBarOUTLINE.Thickness = 3
    HealthBarOUTLINE.Filled = false
    HealthBarOUTLINE.Color = Color3.new(0,0,0)
    HealthBarOUTLINE.Transparency = 1
    HealthBarOUTLINE.Visible = false

    local HealthBarITSELF = Drawing.new("Square")
    HealthBarITSELF.Thickness = 1
    HealthBarITSELF.Filled = false
    HealthBarITSELF.Transparency = 1
    HealthBarITSELF.Visible = false
    
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1,1,1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    local Name = Drawing.new("Text")
    Name.Transparency = 1
    Name.Visible = false
    Name.Color = taffy_esp.name.color
    Name.Size = 16
    Name.Center = true
    Name.Outline = false
    Name.Font = 2
    Name.Text = "name [100/100]"

    local toolshow = Drawing.new("Text")
    toolshow.Transparency = 1
    toolshow.Visible = false
    toolshow.Color = getgenv().taffy_esp.Toolsshow.color
    toolshow.Size = 16
    toolshow.Center = true
    toolshow.Outline = false
    toolshow.Font = 2
    toolshow.Text = ""
game:GetService("RunService").RenderStepped:Connect(function()
        if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health  > 0 and (not taffy_esp.misc.teamcheck or v.TeamColor == lplr.TeamColor) then
            local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)
            local Distance = (CurrentCamera.CFrame.p - v.Character.HumanoidRootPart.Position).Magnitude
            local RootPart = v.Character.HumanoidRootPart
            local Head = v.Character.Head
            local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
            local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + Vector3.new(0,0.5,0))
            local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - Vector3.new(0,3,0))
            if (not taffy_esp.misc.visibleonly or onScreen) then
                if taffy_esp.box.enabled1 then
                    BLOCKOUTLINE.Size = Vector2.new(2500 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BLOCKOUTLINE.Position = Vector2.new(RootPosition.X - BLOCKOUTLINE.Size.X / 2, RootPosition.Y - BLOCKOUTLINE.Size.Y / 2)
                    BLOCKOUTLINE.Visible = taffy_esp.box.outline
                    BLOCKOUTLINE.Color = taffy_esp.box.color2
    
                    BOXPLAYER.Size = Vector2.new(2500 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BOXPLAYER.Position = Vector2.new(RootPosition.X - BOXPLAYER.Size.X / 2, RootPosition.Y - BOXPLAYER.Size.Y / 2)
                    BOXPLAYER.Visible = taffy_esp.box.enabled
                    if not taffy_esp.misc.useteamcolors then
                        local color = v.TeamColor
                        BOXPLAYER.Color = taffy_esp.box.color1
                    else
                        BOXPLAYER.Color = taffy_esp.box.color1
                    end
                        
                    HealthBarOUTLINE.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                    HealthBarOUTLINE.Position = HealthBarOUTLINE.Position - Vector2.new(6,0)
                    HealthBarOUTLINE.Visible = taffy_esp.box.outline
    
                    HealthBarITSELF.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) / (v.Character.Humanoid.MaxHealth / math.clamp(v.Character.Humanoid.Health, 0,v.Character.Humanoid.MaxHealth)))
                    HealthBarITSELF.Position = Vector2.new(BOXPLAYER.Position.X - 5, BOXPLAYER.Position.Y + (1 / HealthBarITSELF.Size.Y))
                    HealthBarITSELF.Color = taffy_esp.box.healthbarcolor
                    HealthBarITSELF.Visible = taffy_esp.box.healthbar
                    
                    
                    
                    
                else
                    BLOCKOUTLINE.Visible = false
                    BOXPLAYER.Visible = false
                    HealthBarOUTLINE.Visible = false
                    HealthBarITSELF.Visible = false
                end
                if taffy_esp.tracer.enabled then
                    if taffy_esp.tracer.unlocktracers then
                        Tracer.From = Vector2.new(mouse.X, mouse.Y + 36)
                    else
                        Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    end
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)
                    Tracer.Visible = taffy_esp.tracer.enabled
                    if not taffy_esp.misc.useteamcolors then
                        local color = v.TeamColor
                        Tracer.Color = taffy_esp.tracer.color
                    else
                        Tracer.Color = taffy_esp.tracer.color
                    end
                else
                    Tracer.Visible = false
                end

                if taffy_esp.Toolsshow.enable then
                      local Equipped = v.Character:FindFirstChildOfClass("Tool") and v.Character:FindFirstChildOfClass("Tool").Name or ""
                    toolshow.Text = Equipped
                    toolshow.Position = Vector2.new(workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).X, workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).Y + 30)
                    toolshow.Color = getgenv().taffy_esp.Toolsshow.color
                    toolshow.Font = 3
                    Name.Size = taffy_esp.Toolsshow.size
                    toolshow.Visible = true
                    else
                        toolshow.Visible = false
                end


                if taffy_esp.name.enabled then
                    Name.Text = tostring(v.Character.Humanoid.DisplayName).. " [" .. tostring(math.floor(v.Character.Humanoid.Health + 0.5)) .. "/" .. tostring(v.Character.Humanoid.MaxHealth) .. "]"
                    Name.Position = Vector2.new(workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).X, workspace.Camera:WorldToViewportPoint(v.Character.Head.Position).Y - 30)
                    Name.Visible = true
                    Name.Size = taffy_esp.name.size
                    if not taffy_esp.misc.useteamcolors then
                        local color = v.TeamColor
                        Name.Color = taffy_esp.name.color
                    else
                        Name.Color = taffy_esp.name.color
                    end
                    Name.Outline = taffy_esp.name.outline
                else
                    Name.Visible = false
                end
            else
                BLOCKOUTLINE.Visible = false
                BOXPLAYER.Visible = false
                toolshow.Visible=false
                HealthBarOUTLINE.Visible = false
                HealthBarITSELF.Visible = false
                Tracer.Visible = false
                Name.Visible = false
            end
        else
            toolshow.Visible=false
            BLOCKOUTLINE.Visible = false
            BOXPLAYER.Visible = false
            HealthBarOUTLINE.Visible = false
            HealthBarITSELF.Visible = false
            Tracer.Visible = false
            Name.Visible = false
        end
    end)
end

for i,v in pairs(game.Players:GetChildren()) do
    esp(v)
end

game.Players.PlayerAdded:Connect(function(v)
    esp(v)
end)

local ruby = {
    Misc = {
        SpamCall = nil
    },
    UISettings = {
        Rainbow = nil
    },
    Aiming = {
        Aimbot = {
            Enabled = nil,
            Prediction = nil,
            Hitbox = nil,
            Smoothing = {
                Enabled = nil,
                Value = nil
            },
            WallCheck = nil,
            VelocityResolver = nil,
            ReverseResolver = nil,
            Alerts = nil
        },
        Target = {
            Enabled = nil,
            Prediction = nil,
            Hitbox = nil,
            Alerts = nil,
            Randomize = nil,
            Tracer = {
                Enabled = nil,
                Color = nil,
                From = nil,
            },
            PingBased = nil,
            AutoPred = nil,
            Highlight = {
                Enabled = nil,
                FillColor = nil,
                OutlineColor = nil
            },
            LookAt = nil,
            ViewAt = nil,
            Stats = nil,
            FakeHitbox = {
                Enabled = nil,
                Color = nil,
                Size = nil,
                Material = nil
            },
            Offset = {
                Y = nil
            },
            Dot = {
                Enabled = nil,Color = nil
            }
        },
        WristPos = {
            Enabled = nil,
            Distance = nil
        },
        TargetStrafe = {
            Enabled = nil,
            Speed = nil,
            Distance = nil,
            Height = nil,
            Visualize = {
                Enabled = nil,
                Color = nil
            }
        }
    },
    Blatant = {
        CFrame = {
            Enabled = nil,
            Value = nil
        },
        Exploits = {
            AutoStomp = nil,
            AntiBag = nil,
            NoSlow = nil,
            JumpCooldown = nil,
            Reach = nil,
            AutoCashPick = nil,
            LockDetector = nil
        },
        AntiStomp = {
            Enabled = nil,
            Type = nil
        },
        FakeLag = {
            Enabled = nil,
            Duration = nil
        },
        AntiAim = {
            SemiLegit = nil,
            DesyncAntiLock = nil,
            DesyncUnhittable = nil,
            LayVis = nil,
            NoPred = nil,
            PredBreaker = nil,
            RotVelocity = {
                Enabled = nil,Value = nil
            }
        },
        GunMod = {
            AutoReload = nil
        },
        Resolver = {
            UnderGroundResolver = nil,
            ZeroPred = nil,
            VelocityCap = nil
        },
    },
    Visuals = {
        Local = {
            Chams = nil,
            Highlight = {
                Enabled = nil,
                FillColor = nil,
                OutlineColor = nil,
            },
            CloneChams = {
                Enabled = nil,
                Duration = nil,
                Color = nil,
                Material = nil,
            },
            BulletTracer = {
                Enabled = nil,
                Color = nil
            }
        },
    }
}
   

local LocalPlayer = game.Players.LocalPlayer

local LocalPlayerObjs = {
    Mouse = LocalPlayer:GetMouse()
}

local RunService = game:GetService("RunService")

local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/derrtyb/scripts/main/LinoriaLibEdit'))()
local ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'ruby | red.#7074',
    Center = true, 
    AutoShow = true,
})

local Tabs = {
    Aiming = Window:AddTab('Aiming'), 
    Blatant = Window:AddTab('Blatant'),
    Visuals = Window:AddTab('Visuals'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('Settings'),
}

local AimbotTab = Tabs.Aiming:AddLeftGroupbox('Camlock')
local TargetTab = Tabs.Aiming:AddRightGroupbox('Target Aim')
local WristPosXOther = Tabs.Aiming:AddLeftTabbox()
local WristPositionTab = WristPosXOther:AddTab('Wrist Pos')
local StrafeTab = WristPosXOther:AddTab('Strafe')
local TargetResolverTab = WristPosXOther:AddTab('Resolver')

local ExploitsTab = Tabs.Blatant:AddLeftGroupbox('Exploits')
local FlyTab = Tabs.Blatant:AddRightGroupbox('Fly')
local CFrameTab = Tabs.Blatant:AddRightGroupbox('CFrame')
local AntiStompTab = Tabs.Blatant:AddLeftGroupbox('Anti-Stomp')
local FakeLagTab = Tabs.Blatant:AddRightGroupbox('Fake Lag')
local AntiAimTab = Tabs.Blatant:AddRightGroupbox('Anti Aim (use one at a time)')
local SpinbotTab = Tabs.Blatant:AddLeftGroupbox('Spinbot')
local removehitboxTab = Tabs.Blatant:AddRightGroupbox('Remove Bodyparts')

local LocalTab = Tabs.Visuals:AddRightGroupbox('Character')
local FOVTag = Tabs.Visuals:AddRightGroupbox('FOV')
local ESPTab = Tabs.Visuals:AddLeftGroupbox('ESP')
local WorldTab = Tabs.Visuals:AddLeftGroupbox('World')
local BulletTab = Tabs.Visuals:AddRightGroupbox('Bullet Tracer')

local AnimationsTab = Tabs.Misc:AddLeftGroupbox('Animations')
local FunTab = Tabs.Misc:AddLeftGroupbox('Fun')

local TeleportTab = Tabs.Misc:AddRightGroupbox('Teleports')
local UnfairTab = Tabs.Misc:AddRightGroupbox('Unfair')
local LockDetectorTab = Tabs.Misc:AddRightGroupbox('Lock Detector')

local OtherGroupbox = Tabs["UI Settings"]:AddRightGroupbox('Other')

AimbotTab:AddToggle('AimbotEnabledTggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable Camlock',
})

Toggles.AimbotEnabledTggle:OnChanged(function()
    ruby.Aiming.Aimbot.Enabled = Toggles.AimbotEnabledTggle.Value
end)

Toggles.AimbotEnabledTggle:AddKeyPicker('AimbotKeyPickerXD', {
    Default = 'None', 
    SyncToggleState = false, 

    Mode = 'Toggle',

    Text = 'Camlock', 
    NoUI = false,
})

Options.AimbotKeyPickerXD:OnClick(function()
    if ruby.Aiming.Aimbot.Enabled then
        AimbotBindEnabled = not AimbotBindEnabled
        if AimbotBindEnabled then
            AimbotTarget = AimbotGetTarget()
            if ruby.Aiming.Aimbot.Alerts then
                Library:Notify("Aiming : "..tostring(AimbotTarget.Character.Humanoid.DisplayName))
            end
        elseif not AimbotBindEnabled then
            if ruby.Aiming.Aimbot.Alerts then
                Library:Notify("Unaiming : "..tostring(AimbotTarget.Character.Humanoid.DisplayName))
            end
        end
    end
end)

AimbotTab:AddInput('AimbotPredictionTextbox', {
    Default = '',
    Numeric = false,
    Finished = false,

    Text = 'Prediction',
    Tooltip = 'Camlock Prediction',

    Placeholder = 'Example = 7', 
})

Options.AimbotPredictionTextbox:OnChanged(function()
    ruby.Aiming.Aimbot.Prediction = Options.AimbotPredictionTextbox.Value
end)

AimbotTab:AddToggle('AimbotDrawFOVTggle', {
    Text = 'Draw FOV',
    Default = false, 
    Tooltip = 'Enable Camlock FOV', 
})

Toggles.AimbotDrawFOVTggle:OnChanged(function()
    AimbotDrawFOV = Toggles.AimbotDrawFOVTggle.Value
end)

Toggles.AimbotDrawFOVTggle:AddColorPicker('LocalHighlxxxxxxxxxxightFillColorColorPicker', {
    Default = Color3.fromRGB(255,0,0),
    Title = 'Camlock FOV Color'
})

Options.LocalHighlxxxxxxxxxxightFillColorColorPicker:OnChanged(function()
    AimbotFOVClr = Options.LocalHighlxxxxxxxxxxightFillColorColorPicker.Value
end)

AimbotTab:AddSlider('AimbotFOVSizex', {
    Text = 'Camlock FOV',

    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 2,

    Compact = false,
})

Options.AimbotFOVSizex:OnChanged(function()
    AimbotFOVSize = Options.AimbotFOVSizex.Value*100
end)

AimbotTab:AddDropdown('AimbotHitboxDropdownn', {
    Values = { 'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso' },
    Default = 2,
    Multi = false,

    Text = 'Hitpart',
    Tooltip = 'Camlock Hitpart',
})

Options.AimbotHitboxDropdownn:OnChanged(function()
    ruby.Aiming.Aimbot.Hitbox = Options.AimbotHitboxDropdownn.Value
end)

AimbotTab:AddToggle('AimbotAlertsTggl', {
    Text = 'Alerts',
    Default = false,
    Tooltip = 'Enable Camlock Alerts',
})

Toggles.AimbotAlertsTggl:OnChanged(function()
    ruby.Aiming.Aimbot.Alerts = Toggles.AimbotAlertsTggl.Value
end)

AimbotTab:AddToggle('AimbotVelocityResolverToggle', {
    Text = 'Underground Resolver',
    Default = false,
    Tooltip = 'Stops from shooting floor',
})

Toggles.AimbotVelocityResolverToggle:OnChanged(function()
    ruby.Aiming.Aimbot.VelocityResolver = Toggles.AimbotVelocityResolverToggle.Value
end)

AimbotTab:AddToggle('ReverseResolverAimbotTggle', {
    Text = 'Reverse Resolver',
    Default = false,
    Tooltip = 'Enable Camlock Reverse Resolver',
})

Toggles.ReverseResolverAimbotTggle:OnChanged(function()
    ruby.Aiming.Aimbot.ReverseResolver = Toggles.ReverseResolverAimbotTggle.Value
end)

AimbotTab:AddToggle('AimbotSmoothingTggle', {
    Text = 'Enable Smoothing',
    Default = false,
    Tooltip = 'Enable Camlock Smoothing',
})

Toggles.AimbotSmoothingTggle:OnChanged(function()
    ruby.Aiming.Aimbot.Smoothing.Enabled = Toggles.AimbotSmoothingTggle.Value
end)

AimbotTab:AddInput('AimbotSmoothingTextBox', {
    Default = '',
    Numeric = false,
    Finished = false,

    Text = 'Smoothing Value',
    Tooltip = 'Smoothing Value',

    Placeholder = 'Example = 0.01', 
})

Options.AimbotSmoothingTextBox:OnChanged(function()
    ruby.Aiming.Aimbot.Smoothing.Value = Options.AimbotSmoothingTextBox.Value
end)

--// target
TargetTab:AddToggle('TargetEnabledToggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable Target',
})

Toggles.TargetEnabledToggle:OnChanged(function()
    ruby.Aiming.Target.Enabled = Toggles.TargetEnabledToggle.Value
end)

Toggles.TargetEnabledToggle:AddKeyPicker('TargetKeyPickerXD', {
    Default = 'None', 
    SyncToggleState = false, 

    Mode = 'Toggle',

    Text = 'Target Aim', 
    NoUI = false,
})

Options.TargetKeyPickerXD:OnClick(function()
    if ruby.Aiming.Target.Enabled then
        TargetBindEnabled = not TargetBindEnabled
        if TargetBindEnabled then
            TargetTarget = TargetGetTarget()
            if ruby.Aiming.Target.Alerts then
                Library:Notify("Targeting : "..tostring(TargetTarget.Character.Humanoid.DisplayName))
            end
        elseif not TargetBindEnabled then
            if ruby.Aiming.Target.Alerts then
                Library:Notify("Untargeting : "..tostring(TargetTarget.Character.Humanoid.DisplayName))
            end
        end
    end
end)

TargetTab:AddInput('TargetPredictionTextbox', {
    Default = '',
    Numeric = false,
    Finished = false,

    Text = 'Prediction',
    Tooltip = 'Target Prediction',

    Placeholder = 'Example = 0.125', 
})

Options.TargetPredictionTextbox:OnChanged(function()
    ruby.Aiming.Target.Prediction = Options.TargetPredictionTextbox.Value
end)

TargetTab:AddSlider('AimbotFOVSxizex', {
    Text = 'Target FOV',

    Default = 5,
    Min = 1,
    Max = 5,
    Rounding = 2,

    Compact = false,
})

Options.AimbotFOVSxizex:OnChanged(function()
    TargetFOVSize = Options.AimbotFOVSxizex.Value*100
end)

TargetTab:AddDropdown('TargetHitboxDropdown', {
    Values = { 'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso' },
    Default = 2,
    Multi = false,

    Text = 'Hitpart',
    Tooltip = 'Target Hitpart',
})

Options.TargetHitboxDropdown:OnChanged(function()
    ruby.Aiming.Target.Hitbox = Options.TargetHitboxDropdown.Value
end)

TargetTab:AddToggle('Randomize', {
    Text = 'Randomize Hitparts',
    Default = false,
    Tooltip = 'will make you miss shots',
})

Toggles.Randomize:OnChanged(function()
    ruby.Aiming.Target.Randomize = Toggles.Randomize.Value
end)

game:GetService("RunService").Stepped:Connect(function()
    if Toggles.Randomize.Value then
        wait(0.6)
        player_gayparts = {"Head","UpperTorso","LowerTorso","RightUpperArm","RightLowerArm","LeftLowerArm","LeftUpperArm"}
        ruby.Aiming.Target.Hitbox = player_gayparts[math.random(1,#player_gayparts)]
    else
        ruby.Aiming.Target.Hitbox = Options.TargetHitboxDropdown.Value
    end
end)

TargetTab:AddToggle('TargetAlertsTggl', {
    Text = 'Alerts',
    Default = false,
    Tooltip = 'Enable Target Alerts',
})

Toggles.TargetAlertsTggl:OnChanged(function()
    ruby.Aiming.Target.Alerts = Toggles.TargetAlertsTggl.Value
end)

TargetTab:AddToggle('TargetLookAtTggle', {
    Text = 'Look At',
    Default = false,
    Tooltip = 'Enable Look At',
})

Toggles.TargetLookAtTggle:OnChanged(function()
    ruby.Aiming.Target.LookAt = Toggles.TargetLookAtTggle.Value
end)

TargetTab:AddToggle('TargetViewAtTggle', {
    Text = 'View At',
    Default = false,
    Tooltip = 'Enable View At',
})

Toggles.TargetViewAtTggle:OnChanged(function()
    ruby.Aiming.Target.ViewAt = Toggles.TargetViewAtTggle.Value
end)

TargetTab:AddToggle('Stats', {
    Text = 'Stats',
    Default = false,
    Tooltip = 'Enable Target GUI',
})

Toggles.Stats:OnChanged(function()
    ruby.Aiming.Target.Stats = Toggles.Stats.Value
end)

local Ruby_TargetStats = Instance.new("ScreenGui")
local Background = Instance.new("Frame")
local Picture = Instance.new("ImageLabel")
local Top = Instance.new("Frame")
local UIGradienta = Instance.new("UIGradient")
local UIGradienta_2 = Instance.new("UIGradient")
local HealthBarBackground = Instance.new("Frame")
local UIGradienta_3 = Instance.new("UIGradient")
local HealthBar = Instance.new("Frame")
local HealthText = Instance.new("TextLabel")
local HealthIcon = Instance.new("ImageButton")
local UIGradienta_4 = Instance.new("UIGradient")
local NameOfTarget = Instance.new("TextLabel")

spawn(function()
Ruby_TargetStats.Name = "Ruby_TargetStats"
Ruby_TargetStats.Parent = game.CoreGui
Ruby_TargetStats.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Background.Name = "Background"
Background.Parent = Ruby_TargetStats
Background.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Background.BorderSizePixel = 0
Background.Position = UDim2.new(0.388957828, 0, 0.700122297, 0)
Background.Size = UDim2.new(0, 358, 0, 71)
Background.Visible = false

Picture.Name = "Picture"
Picture.Parent = Background
Picture.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Picture.BorderSizePixel = 0
Picture.Position = UDim2.new(0.0279329624, 0, 0.0704225376, 0)
Picture.Size = UDim2.new(0, 59, 0, 59)
Picture.Transparency = 1
Picture.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"

Top.Name = "Top"
Top.Parent = Background
Top.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Top.BorderSizePixel = 0
Top.Position = UDim2.new(0, 0, -0.101449274, 0)
Top.Size = UDim2.new(0, 358, 0, 7)

UIGradienta.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(15, 15, 15)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(93, 93, 93))}
UIGradienta.Rotation = 90
UIGradienta.Parent = Top

UIGradienta_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(52, 52, 52)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 0, 0))}
UIGradienta_2.Rotation = 90
UIGradienta_2.Parent = Background

HealthBarBackground.Name = "HealthBarBackground"
HealthBarBackground.Parent = Background
HealthBarBackground.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
HealthBarBackground.BorderSizePixel = 0
HealthBarBackground.Position = UDim2.new(0.215083793, 0, 0.348234326, 0)
HealthBarBackground.Size = UDim2.new(0, 270, 0, 19)
HealthBarBackground.Transparency = 1

UIGradienta_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(58, 58, 58)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 30, 30))}
UIGradienta_3.Rotation = 90
UIGradienta_3.Parent = HealthBarBackground

HealthBar.Name = "HealthBar"
HealthBar.Parent = HealthBarBackground
HealthBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
HealthBar.BorderSizePixel = 0
HealthBar.Position = UDim2.new(-0.00336000000, 0.05, 0.164894029, 0)
HealthBar.Size = UDim2.new(0, 130, 0, 19)

HealthText.Name = "HealthText"
HealthText.Parent = HealthBar
HealthText.BackgroundColor3 = Color3.fromRGB(118, 118, 118)
HealthText.BackgroundTransparency = 1.000
HealthText.Size = UDim2.new(0, 170, 0, 22)
HealthText.Font = Enum.Font.Roboto
HealthText.Text = "100"
HealthText.TextColor3 = Color3.fromRGB(255, 255, 255)
HealthText.TextSize = 20.000
HealthText.TextXAlignment = Enum.TextXAlignment.Right

HealthIcon.Name = "HealthIcon"
HealthIcon.Parent = HealthBar
HealthIcon.BackgroundTransparency = 1.000
HealthIcon.Position = UDim2.new(0.0900000036, -0.05, 0.119999997, 0)
HealthIcon.Size = UDim2.new(0, 15, 0, 15)
HealthIcon.ZIndex = 2
HealthIcon.Image = "rbxassetid://3926305904"
HealthIcon.ImageRectOffset = Vector2.new(964, 444)
HealthIcon.ImageRectSize = Vector2.new(36, 36)

UIGradienta_4.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(159, 227, 170)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(88, 156, 95))}
UIGradienta_4.Rotation = 90
UIGradienta_4.Parent = HealthBar

NameOfTarget.Name = "NameOfTarget"
NameOfTarget.Parent = Background
NameOfTarget.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
NameOfTarget.BackgroundTransparency = 1.000
NameOfTarget.Position = UDim2.new(0.220670387, 0, 0.0704225376, 0)
NameOfTarget.Size = UDim2.new(0, 268, 0, 19)
NameOfTarget.Font = Enum.Font.Code
NameOfTarget.TextColor3 = Color3.fromRGB(255, 255, 255)
NameOfTarget.TextScaled = true
NameOfTarget.TextSize = 14.000
NameOfTarget.TextStrokeTransparency = 0.000
NameOfTarget.TextWrapped = true
end)

local Rubyyy = {
    Round = function(num, numDecimalPlaces)
        return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
    end
}

local IsAlive = function(GetPlayer)
    return GetPlayer and GetPlayer.Character and GetPlayer.Character:FindFirstChild("HumanoidRootPart") ~= nil and GetPlayer.Character:FindFirstChild("Humanoid") ~= nil and GetPlayer.Character:FindFirstChild("Head") ~= nil and true or false
end

spawn(function()
    while wait() do
        if ruby.Aiming.Target.Stats and ruby.Aiming.Target.Enabled and TargetBindEnabled then
            if TargetTarget and IsAlive(TargetTarget) then
                Background.Visible = true
                local NewHealth = TargetTarget.Character.Humanoid.Health / TargetTarget.Character.Humanoid.MaxHealth
                NameOfTarget.Text = tostring(TargetTarget.Character.Humanoid.DisplayName).." ("..tostring(TargetTarget.Name)..")"
                Picture.Image  = "rbxthumb://type=AvatarHeadShot&id=" ..TargetTarget.UserId.. "&w=420&h=420"
                HealthBar:TweenSize(UDim2.new(TargetTarget.Character.Humanoid.Health / TargetTarget.Character.Humanoid.MaxHealth, 0, 1, 0), "In", "Linear", 0.25)
                HealthText.Text = (Rubyyy.Round(NewHealth * 100, 2)) .. "/" .. (Rubyyy.Round(TargetTarget.Character.Humanoid.MaxHealth * 1, 2))
                spawn(function()
                    if ruby.Aiming.Target.Stats == false then
                        Background.Visible = false
                    end
                end)
            end
        else
            Background.Visible = false
        end
    end
end)

TargetTab:AddToggle('PingbasedTggle', {
    Text = 'Ping Based',
    Default = false, 
    Tooltip = 'recommended on 100+ ping', 
})

Toggles.PingbasedTggle:OnChanged(function()
    ruby.Aiming.Target.PingBased = Toggles.PingbasedTggle.Value
end)

TargetTab:AddToggle('AutoPred', {
    Text = 'Auto Pred',
    Default = false, 
    Tooltip = 'best on low ping', 
})

Toggles.AutoPred:OnChanged(function()
    ruby.Aiming.Target.AutoPred = Toggles.AutoPred.Value
end)

TargetTab:AddToggle('TracerEnabledTracerTarget', {
    Text = 'Tracers',
    Default = false, 
    Tooltip = 'Tracers Enabled', 
})

Toggles.TracerEnabledTracerTarget:OnChanged(function()
    ruby.Aiming.Target.Tracer.Enabled = Toggles.TracerEnabledTracerTarget.Value
end)

Toggles.TracerEnabledTracerTarget:AddColorPicker('AddColorPickerForTracerTargetThingy', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Target Tracer Color'
})

Options.AddColorPickerForTracerTargetThingy:OnChanged(function()
    ruby.Aiming.Target.Tracer.Color = Options.AddColorPickerForTracerTargetThingy.Value
end)

TargetTab:AddDropdown('TargetTracerFrom', {
    Values = { 'Mouse', 'Head', 'UpperTorso', 'LowerTorso','Gun' },
    Default = 5,
    Multi = false, 

    Text = 'Tracer From:',
    Tooltip = 'Tracer From',
})

Options.TargetTracerFrom:OnChanged(function()
    ruby.Aiming.Target.Tracer.From = Options.TargetTracerFrom.Value
end)

TargetTab:AddToggle('HighlightEnabledTggle', {
    Text = 'Highlight',
    Default = false, 
    Tooltip = 'Highlight Enabled', 
})

Toggles.HighlightEnabledTggle:OnChanged(function()
    ruby.Aiming.Target.Highlight.Enabled = Toggles.HighlightEnabledTggle.Value
end)

Toggles.HighlightEnabledTggle:AddColorPicker('HighlightFillColorColorPicker', {
    Default = Color3.fromRGB(255,0,0),
    Title = 'Highlight Fill Color'
})

Options.HighlightFillColorColorPicker:OnChanged(function()
    ruby.Aiming.Target.Highlight.FillColor = Options.HighlightFillColorColorPicker.Value
end)

Toggles.HighlightEnabledTggle:AddColorPicker('HighlightOutLineColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Highlight Outline Color'
})

Options.HighlightOutLineColor:OnChanged(function()
    ruby.Aiming.Target.Highlight.OutlineColor = Options.HighlightOutLineColor.Value
end)


TargetTab:AddToggle('DotPARENTEnabedx', {
    Text = 'Dot',
    Default = false, 
    Tooltip = 'Dot Enabled', 
})

Toggles.DotPARENTEnabedx:OnChanged(function()
    ruby.Aiming.Target.Dot.Enabled = Toggles.DotPARENTEnabedx.Value
end)

Toggles.DotPARENTEnabedx:AddColorPicker('DotParentForColorxXD', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Dot Color'
})

Options.DotParentForColorxXD:OnChanged(function()
    ruby.Aiming.Target.Dot.Color = Options.DotParentForColorxXD.Value
end)

TargetTab:AddSlider('TargetOffsetYSlider', {
    Text = 'Target Offset (Y)',

    Default = 0,
    Min = -0.5,
    Max = 0.5,
    Rounding = 2,

    Compact = false,
})

Options.TargetOffsetYSlider:OnChanged(function()
    ruby.Aiming.Target.Offset.Y = Options.TargetOffsetYSlider.Value
end)

WristPositionTab:AddToggle('WristPosEnabledTggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable Wrist Position',
})

Toggles.WristPosEnabledTggle:OnChanged(function()
    ruby.Aiming.WristPos.Enabled = Toggles.WristPosEnabledTggle.Value
end)

Toggles.WristPosEnabledTggle:AddKeyPicker('WristPosBindEnabled', {
    Default = 'None', 
    SyncToggleState = false, 

    Mode = 'Toggle',

    Text = 'Wrist Position', 
    NoUI = false,
})

Options.WristPosBindEnabled:OnClick(function()
    if ruby.Aiming.WristPos.Enabled then
        WristPosBind = not WristPosBind
        WristPosTarget = GetTarget()
    end
end)

WristPositionTab:AddSlider('WristPosOffsetSlider', {
    Text = 'Offset (Y)',

    Default = 1,
    Min = 1,
    Max = 25,
    Rounding = 2,

    Compact = false,
})

Options.WristPosOffsetSlider:OnChanged(function()
    ruby.Aiming.WristPos.Distance = Options.WristPosOffsetSlider.Value
end)

WristPositionTab:AddLabel("(flings wrist around target)")
WristPositionTab:AddLabel("(when wrist is broken some")
WristPositionTab:AddLabel("anti aims will not work)")

StrafeTab:AddToggle('TargetStrafeEnabled', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable Target Strafe Enabled',
})

Toggles.TargetStrafeEnabled:OnChanged(function()
    ruby.Aiming.TargetStrafe.Enabled = Toggles.TargetStrafeEnabled.Value
end)

StrafeTab:AddToggle('TargetStrafeVisualizatiONcOLR', {
    Text = 'Visualize Rotation',
    Default = false, 
    Tooltip = 'Visualize Rotation Enabled', 
})

Toggles.TargetStrafeVisualizatiONcOLR:OnChanged(function()
    ruby.Aiming.TargetStrafe.Visualize.Enabled = Toggles.TargetStrafeVisualizatiONcOLR.Value
end)

Toggles.TargetStrafeVisualizatiONcOLR:AddColorPicker('TargetStrafeVisualizatiONcOLRXX', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Visualize Rotation Color'
})

Options.TargetStrafeVisualizatiONcOLRXX:OnChanged(function()
    ruby.Aiming.TargetStrafe.Visualize.Color = Options.TargetStrafeVisualizatiONcOLRXX.Value
end)

StrafeTab:AddSlider('TargetStrafeSpeedLSid', {
    Text = 'Speed',

    Default = 5,
    Min = 1,
    Max = 5,
    Rounding = 0,

    Compact = false,
})

Options.TargetStrafeSpeedLSid:OnChanged(function()
    if Options.TargetStrafeSpeedLSid.Value == 5 then
        ruby.Aiming.TargetStrafe.Speed = 0.5
    elseif Options.TargetStrafeSpeedLSid.Value == 4 then
        ruby.Aiming.TargetStrafe.Speed = 0.6
    elseif Options.TargetStrafeSpeedLSid.Value == 3 then
        ruby.Aiming.TargetStrafe.Speed = 0.7
    elseif Options.TargetStrafeSpeedLSid.Value == 2 then
        ruby.Aiming.TargetStrafe.Speed = 0.8
    elseif Options.TargetStrafeSpeedLSid.Value == 1 then
        ruby.Aiming.TargetStrafe.Speed = 0.9
    end
end)

StrafeTab:AddSlider('TargetStrafeDistanceSlid', {
    Text = 'Distance',

    Default = 0,
    Min = 0,
    Max = 20,
    Rounding = 2,

    Compact = false,
})

Options.TargetStrafeDistanceSlid:OnChanged(function()
    ruby.Aiming.TargetStrafe.Distance = Options.TargetStrafeDistanceSlid.Value
end)

StrafeTab:AddSlider('TargetStrafeHeightSlid', {
    Text = 'Height',

    Default = 0,
    Min = 0,
    Max = 20,
    Rounding = 2,

    Compact = false,
})

Options.TargetStrafeHeightSlid:OnChanged(function()
    ruby.Aiming.TargetStrafe.Height = Options.TargetStrafeHeightSlid.Value
end)

StrafeTab:AddLabel("(FPS based)")

ExploitsTab:AddToggle('JumpCooldownTggle', {
    Text = 'No Jump Cooldown',
    Default = false, 
    Tooltip = 'Removes Jump Cooldown', 
})

Toggles.JumpCooldownTggle:OnChanged(function()
    ruby.Blatant.Exploits.JumpCooldown = Toggles.JumpCooldownTggle.Value
end)

ExploitsTab:AddToggle('NoSlowdownTgle', {
    Text = 'No Slowdown',
    Default = false, 
    Tooltip = 'Enable No Slowdown', 
})

Toggles.NoSlowdownTgle:OnChanged(function()
    ruby.Blatant.Exploits.NoSlow = Toggles.NoSlowdownTgle.Value
end)

ExploitsTab:AddToggle('AutoStompTggle', {
    Text = 'Auto Stomp',
    Default = false, 
    Tooltip = 'Enable Auto Stomp', 
})

Toggles.AutoStompTggle:OnChanged(function()
    ruby.Blatant.Exploits.AutoStomp = Toggles.AutoStompTggle.Value
end)

ExploitsTab:AddToggle('AntiFlingEnabled', {
    Text = 'Anti-Fling',
    Default = false, 
    Tooltip = 'Anchor in Place', 
})

Toggles.AntiFlingEnabled:OnChanged(function()
    LocalPlayer.Character.HumanoidRootPart.Anchored = Toggles.AntiFlingEnabled.Value
end)

ExploitsTab:AddToggle('AntiBagEnabledx', {
    Text = 'Anti-Bag (dont use with antis)',
    Default = false, 
    Tooltip = 'Enable Anti-Bag', 
})

Toggles.AntiBagEnabledx:OnChanged(function()
    ruby.Blatant.Exploits.AntiBag = Toggles.AntiBagEnabledx.Value
end)

ExploitsTab:AddToggle('ReachEnabled', {
    Text = 'Reach',
    Default = false, 
    Tooltip = 'Enable Reach', 
})

Toggles.ReachEnabled:OnChanged(function()
    ruby.Blatant.Exploits.Reach = Toggles.ReachEnabled.Value
end)

ExploitsTab:AddToggle('AutoCashPick', {
    Text = 'Cash Aura',
    Default = false, 
    Tooltip = 'Takes Cash Nearby', 
})

Toggles.AutoCashPick:OnChanged(function()
    ruby.Blatant.Exploits.AutoCashPick = Toggles.AutoCashPick.Value
end)

ExploitsTab:AddToggle('NoclipEnabled', {
    Text = 'Noclip',
    Default = false, 
    Tooltip = 'Enable Noclip', 
})

Toggles.NoclipEnabled:OnChanged(function()
    if Toggles.NoclipEnabled.Value then
        NoclipLoop = game:GetService("RunService").Stepped:Connect(function()
            for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
                if v:IsA("BasePart") and v.CanCollide == true then
                    v.CanCollide = false
                end
            end
        end)
    elseif Toggles.NoclipEnabled.Value == false and NoclipLoop then
        NoclipLoop:Disconnect()
    end
end)

LockDetectorTab:AddButton('Lock Detector (f to use)', function()
    local placemarker = Instance.new("Part", game.Workspace)
    local Plr
    local enableddd = false
    local CC = game:GetService'Workspace'.CurrentCamera
    
    function makemarker(Parent, Adornee, Color, Size, Size2)
        local e = Instance.new("BillboardGui", Parent)
        e.Name = "PP"
        e.Adornee = Adornee
        e.Size = UDim2.new(Size, Size2, Size, Size2)
        e.AlwaysOnTop = true
        local a = Instance.new("Frame", e)
        a.Size = UDim2.new(1, 0, 1, 0)
        a.BackgroundTransparency = 0.4
        a.BackgroundColor3 = Color
        local g = Instance.new("UICorner", a)
        g.CornerRadius = UDim.new(30, 30)
        return(e)
    end
    
    function getClosestPlayerToCursor()
        local closestPlayer
        local shortestDistance = math.huge
    
        for i, v in pairs(game.Players:GetPlayers()) do
            if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("Head") then
                local pos = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
                local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(mouse.X, mouse.Y)).magnitude
                if magnitude < shortestDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
       return closestPlayer
    end
    
    mouse.KeyDown:Connect(function(k)
        if k ~= "f" then return end
        if enableddd then
            enableddd = false
            placemarker.Transparency = 1
        else
            placemarker.Transparency = 0
            enableddd = true 
            Plr = getClosestPlayerToCursor()
        end    
    end)
    
        placemarker.Anchored = true
        placemarker.CanCollide = false
        placemarker.Size = Vector3.new(0.1, 0.1, 0.1)
        placemarker.Transparency = 1
        makemarker(placemarker, placemarker, Color3.fromRGB(0, 221, 255), 1, 0)
    
      game:GetService"RunService".Stepped:connect(function()
      if enableddd and Plr.Character then
           placemarker.CFrame = CFrame.new(Plr.Character.BodyEffects.MousePos.Value)
        end
    end)    
end)

LockDetectorTab:AddLabel('(shows where the person will')
LockDetectorTab:AddLabel('shoot, if the dot looks')
LockDetectorTab:AddLabel('"locked on" to a player,')
LockDetectorTab:AddLabel('then person = locking)')

AntiStompTab:AddButton('Force Reset', function()
    for L_170_forvar0, L_171_forvar1 in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
        if L_171_forvar1:IsA("BasePart") then
            L_171_forvar1:Destroy()
        end
    end
end)

AntiStompTab:AddToggle('aNTIStompTggle', {
    Text = 'Enable',
    Default = false, 
    Tooltip = 'Enable AntiStomp', 
})

Toggles.aNTIStompTggle:OnChanged(function()
    ruby.Blatant.AntiStomp.Enabled = Toggles.aNTIStompTggle.Value
end)

AntiStompTab:AddDropdown('AntiStompDropdown', {
    Values = { 'Remove Character', 'Remove Humanoid' },
    Default = 1,
    Multi = false, 

    Text = 'Anti Stomp Type',
    Tooltip = 'Anti Stomp Type',
})

Options.AntiStompDropdown:OnChanged(function()
    ruby.Blatant.AntiStomp.Type = Options.AntiStompDropdown.Value
end)

CFrameTab:AddToggle('CFrameSpeedTggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable CFrame',
})

Toggles.CFrameSpeedTggle:OnChanged(function()
    ruby.Blatant.CFrame.Enabled = Toggles.CFrameSpeedTggle.Value
end)

Toggles.CFrameSpeedTggle:AddKeyPicker('CFrameSpeedBind', {
    Default = 'None', 
    SyncToggleState = false, 

    Mode = 'Toggle',

    Text = 'CFrame', 
    NoUI = false,
})

Options.CFrameSpeedBind:OnClick(function()
    if ruby.Blatant.CFrame.Enabled then
        CFrameBindEnabled = not CFrameBindEnabled
    end
end)

CFrameTab:AddSlider('CFrameSpeedAmountXD', {
    Text = 'CFrame Speed Amount',

    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 2,

    Compact = false,
})

Options.CFrameSpeedAmountXD:OnChanged(function()
    ruby.Blatant.CFrame.Value = Options.CFrameSpeedAmountXD.Value
end)

FakeLagTab:AddToggle('FakeLagEnabledTggle', {
    Text = 'Enable',
    Default = false, 
    Tooltip = 'Enable Fake Lag', 
})

Toggles.FakeLagEnabledTggle:OnChanged(function()
    ruby.Blatant.FakeLag.Enabled = Toggles.FakeLagEnabledTggle.Value
end)

FakeLagTab:AddSlider('FakeLagEnabledSlider', {
    Text = 'Duration',

    Default = 1,
    Min = 1,
    Max = 10,
    Rounding = 2,

    Compact = false,
})

Options.FakeLagEnabledSlider:OnChanged(function()
    ruby.Blatant.FakeLag.Duration = Options.FakeLagEnabledSlider.Value
end)

TargetResolverTab:AddLabel("(Target Aim Only)")

TargetResolverTab:AddToggle('UnderGroundResolver', {
    Text = 'Underground Resolver',
    Default = false, 
    Tooltip = 'Resolves Basic Anti-Lock', 
})

Toggles.UnderGroundResolver:OnChanged(function()
    ruby.Blatant.Resolver.UnderGroundResolver = Toggles.UnderGroundResolver.Value
end)

TargetResolverTab:AddToggle('ZeroPred', {
    Text = 'No Prediction',
    Default = false, 
    Tooltip = 'Works Best on Low Ping', 
})

Toggles.ZeroPred:OnChanged(function()
    ruby.Blatant.Resolver.ZeroPred = Toggles.ZeroPred.Value
end)

TargetResolverTab:AddToggle('VelocityCap', {
    Text = 'Velocity Cap (WIP)',
    Default = false, 
    Tooltip = 'Caps Aimlock Velocity', 
})

Toggles.VelocityCap:OnChanged(function()
    ruby.Blatant.Resolver.VelocityCap = Toggles.VelocityCap.Value
end)

TargetResolverTab:AddSlider('VCapX', {
    Text = 'X',

    Default = 750,
    Min = 0,
    Max = 1000,
    Rounding = 0,

    Compact = false,
})

Options.VCapX:OnChanged(function()
    VCapX = Options.VCapX.Value
end)

TargetResolverTab:AddSlider('VCapY', {
    Text = 'Y',

    Default = 750,
    Min = 0,
    Max = 1000,
    Rounding = 0,

    Compact = false,
})

Options.VCapY:OnChanged(function()
    VCapY = Options.VCapY.Value
end)

TargetResolverTab:AddSlider('VCapZ', {
    Text = 'Z',

    Default = 750,
    Min = 0,
    Max = 1000,
    Rounding = 0,

    Compact = false,
})

Options.VCapZ:OnChanged(function()
    VCapZ = Options.VCapZ.Value
end)

AntiAimTab:AddToggle('DesyncAntiLock', {
    Text = 'Anti Lock (flings closeby)',
    Default = false, 
    Tooltip = 'looks blatant on other screens', 
})

Toggles.DesyncAntiLock:OnChanged(function()
    ruby.Blatant.AntiAim.DesyncAntiLock = Toggles.DesyncAntiLock.Value
end)

local antilock = nil
local noob = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer
local lol = LocalPlayer:GetMouse()

noob.heartbeat:Connect(function()
    if antilock == true then 
    local abc = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
    game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(1,1,1) * (2^16)
    noob.RenderStepped:Wait()
    game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = abc
    end 
end)

AntiAimTab:AddToggle('PredBreaker', {
    Text = 'Prediction Breaker',
    Default = false, 
    Tooltip = 'MAKE SURE "NO SLOWDOWN" IS OFF', 
})

Toggles.PredBreaker:OnChanged(function()
    ruby.Blatant.AntiAim.PredBreaker = Toggles.PredBreaker.Value
end)

AntiAimTab:AddToggle('DesyncUnhittable', {
    Text = 'Spin Desync (also flings)',
    Default = false, 
    Tooltip = 'Stand still to use', 
})

Toggles.DesyncUnhittable:OnChanged(function()
    ruby.Blatant.AntiAim.DesyncUnhittable = Toggles.DesyncUnhittable.Value
end)

        checkcaller = checkcaller
        newcclosure = newcclosure
        hookmetamethod = hookmetamethod

        local PastedSources = nil
        local BruhXD = game:GetService("RunService")
        local LocalPlayer = game:GetService("Players").LocalPlayer
        local Bullshit = LocalPlayer:GetMouse()

        function RandomNumberRange(a)
            return math.random(-a * 100, a * 100) / 100
        end

        function RandomVectorRange(a, b, c)
            return Vector3.new(RandomNumberRange(a), RandomNumberRange(b), RandomNumberRange(c))
        end

        local DesyncTypes = {}
        BruhXD.Heartbeat:Connect(function()
            if PastedSources == true then
                DesyncTypes[1] = LocalPlayer.Character.HumanoidRootPart.CFrame
                DesyncTypes[2] = LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity

                local SpoofThis = LocalPlayer.Character.HumanoidRootPart.CFrame

                SpoofThis = SpoofThis * CFrame.new(Vector3.new(0, 0, 0))
                SpoofThis = SpoofThis * CFrame.Angles(math.rad(RandomNumberRange(180)), math.rad(RandomNumberRange(180)), math.rad(RandomNumberRange(180)))

                LocalPlayer.Character.HumanoidRootPart.CFrame = SpoofThis

                LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(1, 1, 1) * 16384

                BruhXD.RenderStepped:Wait()

                LocalPlayer.Character.HumanoidRootPart.CFrame = DesyncTypes[1]
                LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = DesyncTypes[2]
            end
        end)

        --// Hook_CFrame
        local XDDDDDD = nil
        XDDDDDD = hookmetamethod(game, "__index", newcclosure(function(self, key)
            if PastedSources == true then
                if not checkcaller() then
                    if key == "CFrame" and PastedSources == true and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character:FindFirstChild("Humanoid").Health > 0 then
                        if self == LocalPlayer.Character.HumanoidRootPart then
                            return DesyncTypes[1] or CFrame.new()
                        end
                    end
                end
            end
            return XDDDDDD(self, key)
        end))

AntiAimTab:AddToggle('LayVis', {
    Text = 'Semi-Invis',
    Default = false, 
    Tooltip = 'Lays Under the Road', 
})

Toggles.LayVis:OnChanged(function()
    ruby.Blatant.AntiAim.LayVis = Toggles.LayVis.Value
end)

local desync_stuff = {}
local desync = false
local cframetpdesynctype = "Layvis"
local visualizemodellol = true
local r6_dummy = game:GetObjects("rbxassetid://9474737816")[1]
    r6_dummy.Head.Face:Destroy()
        for i, v in pairs(r6_dummy:GetChildren()) do
            v.Transparency = v.Name == "HumanoidRootPart" and 1 or 0.70
            v.Material = "Neon"
            v.Color = Color3.fromRGB(255, 139, 139)
            v.CanCollide = false
            v.Anchored = false
        end
        
        game:GetService("RunService").heartbeat:Connect(
        function()
            if desync == true then
                desync_stuff[1] = lplr.Character.HumanoidRootPart.CFrame
                local fakeCFrame = lplr.Character.HumanoidRootPart.CFrame
            if cframetpdesynctype == "Layvis" then
                    fakeCFrame = fakeCFrame * CFrame.new(0, -5, 0)
                    fakeCFrame = fakeCFrame * CFrame.Angles(1.55, 0, 0)
                    if visualizemodellol == true then
                        r6_dummy.Parent = workspace
                        r6_dummy.HumanoidRootPart.Velocity = Vector3.new()
                        r6_dummy:SetPrimaryPartCFrame(fakeCFrame)
                    else
                        r6_dummy.Parent = nil
                    end
                    lplr.Character.HumanoidRootPart.CFrame = fakeCFrame
                game:GetService("RunService").RenderStepped:Wait()
                lplr.Character.HumanoidRootPart.CFrame = desync_stuff[1]
                else
                    if r6_dummy.Parent ~= nil then
                        r6_dummy.Parent = nil
                    end
                end
            end
        end)    
                local oldIndex
    oldIndex =
        hookmetamethod(
        game,
        "__index",
        newcclosure(
            function(self, key)
                if not velocitywalk == true or enablehitpartdesync == true then
                    if not checkcaller() then
                        if
                            key == "CFrame" and desync and lplr.Character and
                                lplr.Character:FindFirstChild("HumanoidRootPart") and
                                lplr.Character:FindFirstChild("Humanoid") and
                                lplr.Character:FindFirstChild("Humanoid").Health > 0
                            then
                            if self == lplr.Character.HumanoidRootPart then
                                return desync_stuff[1] or CFrame.new()
                            elseif self == lplr.Character.Head then
                                return desync_stuff[1] and
                                    desync_stuff[1] +
                                        Vector3.new(0, lplr.Character.HumanoidRootPart.Size / 2 + 0.5, 0) or
                                    CFrame.new()
                            end
                        end
                    end
                end
                return oldIndex(self, key)
            end
        )
    )                        

Toggles.LayVis:AddKeyPicker('LayBind', {
    Default = 'None', 
    SyncToggleState = true, 

    Mode = 'Toggle',

    Text = 'Invis', 
    NoUI = false,
})

AntiAimTab:AddToggle('VFallTggle', {
    Text = 'Velocity Fall',
    Default = false, 
    Tooltip = 'Velocity Fall Enabled', 
})

Toggles.VFallTggle:OnChanged(function()
    if Toggles.VFallTggle.Value then
        VFallHook = RunService.Stepped:Connect(function ()
            LocalPlayer.Character:WaitForChild("Humanoid").StateChanged:Connect(function(old,new)
                if new == Enum.HumanoidStateType.Freefall == true and Toggles.VFallTggle.Value == true then
                    wait(0.28)
                    LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, -V_FallVelocity, 0)
                end
            end)
        end)
    elseif Toggles.VFallTggle.Value == false and VFallHook then
        VFallHook:Disconnect()
    end
end)

AntiAimTab:AddSlider('VFallVel', {
    Text = 'V-Fall Velocity',

    Default = 1,
    Min = 1,
    Max = 50,
    Rounding = 2,

    Compact = false,
})

Options.VFallVel:OnChanged(function()
    V_FallVelocity = Options.VFallVel.Value
end)


SpinbotTab:AddToggle('RotVelocitySpinbot', {
    Text = 'Enable',
    Default = false, 
    Tooltip = 'Spinbot Enabled', 
})

Toggles.RotVelocitySpinbot:OnChanged(function()
    spinnybot = Toggles.RotVelocitySpinbot.Value
end)

SpinbotTab:AddSlider('SpinbotY', {
    Text = 'Speed',

    Default = 1,
    Min = 1,
    Max = 100,
    Rounding = 2,

    Compact = false,
})

Options.SpinbotY:OnChanged(function()
    Spinbot_Y = Options.SpinbotY.Value
end)

removehitboxTab:AddDropdown('RemovalDropdown', {
    Values = { 'None','RightLeg', 'LeftLeg',"LeftArm" },
    Default = 1,
    Multi = false, 

    Text = 'Type',
    Tooltip = 'Remove Bodyparts',
})

Options.RemovalDropdown:OnChanged(function()
    if Options.RemovalDropdown.Value == "None" then
    elseif Options.RemovalDropdown.Value == "RightLeg" then
        game.Players.LocalPlayer.Character.RightUpperLeg:Destroy()
    elseif Options.RemovalDropdown.Value == "LeftLeg" then
        game.Players.LocalPlayer.Character.LeftUpperLeg:Destroy()
        elseif Options.RemovalDropdown.Value == "LeftArm" then
        game.Players.LocalPlayer.Character.LeftUpperArm:Destroy()
end
end)

LocalTab:AddToggle('ChamsEnabledTggle', {
    Text = 'Enable Chams',
    Default = false,
    Tooltip = 'Enable Chams',
})

Toggles.ChamsEnabledTggle:OnChanged(function()
    ruby.Visuals.Local.Chams = Toggles.ChamsEnabledTggle.Value
end)

task.spawn(function ()
    while true do
        wait()
        if ruby.Visuals.Local.Chams then
            for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.Material = "ForceField"
                end
            end
        else
            for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.Material = "Plastic"
                end
            end
        end
    end
end)


local LocalHL = Instance.new("Highlight")

LocalTab:AddToggle('LocalHighlight', {
    Text = 'Highlight',
    Default = false, 
    Tooltip = 'Highlight Enabled', 
})

Toggles.LocalHighlight:OnChanged(function()
    ruby.Visuals.Local.Highlight.Enabled = Toggles.LocalHighlight.Value
end)

task.spawn(function ()
    while true do
        wait()
        if ruby.Visuals.Local.Highlight.Enabled then
            LocalHL.Parent = LocalPlayer.Character
            LocalHL.FillColor = ruby.Visuals.Local.Highlight.FillColor
            LocalHL.OutlineColor = ruby.Visuals.Local.Highlight.OutlineColor
        else
            LocalHL.Parent = game.CoreGui
        end
    end
end)

Toggles.LocalHighlight:AddColorPicker('LocalHighlightFillColorColorPicker', {
    Default = Color3.fromRGB(255,0,0),
    Title = 'Highlight Fill Color'
})

Options.LocalHighlightFillColorColorPicker:OnChanged(function()
    ruby.Visuals.Local.Highlight.FillColor = Options.LocalHighlightFillColorColorPicker.Value
end)

Toggles.LocalHighlight:AddColorPicker('LocalHighlightOutLineColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Highlight Outline Color'
})

Options.LocalHighlightOutLineColor:OnChanged(function()
    ruby.Visuals.Local.Highlight.OutlineColor = Options.LocalHighlightOutLineColor.Value
end)

LocalTab:AddToggle('CloneChamsEnabled', {
    Text = 'Clone Chams',
    Default = false, 
    Tooltip = 'Clone Chams Enabled', 
})

Toggles.CloneChamsEnabled:OnChanged(function()
    ruby.Visuals.Local.CloneChams.Enabled = Toggles.CloneChamsEnabled.Value
end)

Toggles.CloneChamsEnabled:AddColorPicker('CloneChamsColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Clone Chams Color'
})

Options.CloneChamsColor:OnChanged(function()
    ruby.Visuals.Local.CloneChams.Color = Options.CloneChamsColor.Value
end)

task.spawn(function ()
    while true do
        wait()
        if ruby.Visuals.Local.CloneChams.Enabled then
            repeat
                game.Players.LocalPlayer.Character.Archivable = true
                local Clone = game.Players.LocalPlayer.Character:Clone()
                for _,Obj in next, Clone:GetDescendants() do
                if Obj.Name == "HumanoidRootPart" or Obj:IsA("Humanoid") or Obj:IsA("LocalScript") or Obj:IsA("Script") or Obj:IsA("Decal") then
                    Obj:Destroy()
                elseif Obj:IsA("BasePart") or Obj:IsA("Meshpart") or Obj:IsA("Part") then
                    if Obj.Transparency == 1 then
                    Obj:Destroy()
                    else
                    Obj.CanCollide = false
                    Obj.Anchored = true
                    Obj.Material = ruby.Visuals.Local.CloneChams.Material
                    Obj.Color = ruby.Visuals.Local.CloneChams.Color
                    Obj.Transparency = 0
                    Obj.Size = Obj.Size + Vector3.new(0.03, 0.03, 0.03)   
                end
            end
                pcall(function()
                    Obj.CanCollide = false
                end)
            end
            Clone.Parent = game.Workspace
            wait(ruby.Visuals.Local.CloneChams.Duration)
            Clone:Destroy()  
            until ruby.Visuals.Local.CloneChams.Enabled == false
        end
    end
end)

LocalTab:AddSlider('DurationSliderWHAT', {
    Text = 'Duration',

    Default = 0.1,
    Min = 0.1,
    Max = 3,
    Rounding = 2,

    Compact = false,
})

Options.DurationSliderWHAT:OnChanged(function()
    ruby.Visuals.Local.CloneChams.Duration = Options.DurationSliderWHAT.Value
end)

LocalTab:AddDropdown('CloneChamsMaterial', {
    Values = { 'Neon', 'ForceField', 'Plastic' },
    Default = 2,
    Multi = false, 

    Text = 'Clone Chams Material',
    Tooltip = 'Clone Chams Material',
})

Options.CloneChamsMaterial:OnChanged(function()
    ruby.Visuals.Local.CloneChams.Material = Options.CloneChamsMaterial.Value
end)

FOVTag:AddSlider('FOVSLlider', {
    Text = 'Amount',

    Default = 80,
    Min = 70,
    Max = 120,
    Rounding = 0,

    Compact = false,
})

Options.FOVSLlider:OnChanged(function()
    workspace.CurrentCamera.FieldOfView = Options.FOVSLlider.Value
end)

ESPTab:AddToggle('BoxESPEnabled', {
    Text = 'Box',
    Default = false, 
    Tooltip = 'Box ESP Enabled', 
})

Toggles.BoxESPEnabled:OnChanged(function()
    getgenv().taffy_esp.box.enabled = Toggles.BoxESPEnabled.Value
end)

Toggles.BoxESPEnabled:AddColorPicker('BoxESPColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Box ESP Color'
})

Options.BoxESPColor:OnChanged(function()
    getgenv().taffy_esp.box.color1 = Options.BoxESPColor.Value
end)

ESPTab:AddToggle('HealthESPEnabled', {
    Text = 'Health',
    Default = false, 
    Tooltip = 'Health ESP Enabled', 
})

Toggles.HealthESPEnabled:OnChanged(function()
    getgenv().taffy_esp.box.healthbar = Toggles.HealthESPEnabled.Value
end)

Toggles.HealthESPEnabled:AddColorPicker('HealthESPColor', {
    Default = Color3.fromRGB(0,255,0),
    Title = 'Health ESP Color'
})

Options.HealthESPColor:OnChanged(function()
    getgenv().taffy_esp.box.healthbarcolor = Options.HealthESPColor.Value
end)
task.spawn(function ()
    while true do
        wait()
        if getgenv().taffy_esp.box.healthbar or getgenv().taffy_esp.box.enabled then
            getgenv().taffy_esp.box.outline = true
        elseif getgenv().taffy_esp.box.healthbar == false or getgenv().taffy_esp.box.enabled == false then
            getgenv().taffy_esp.box.outline = false
        end
        if getgenv().taffy_esp.box.healthbar == true and getgenv().taffy_esp.box.enabled == false then
            getgenv().taffy_esp.box.outline = false
        end
    end
end)

ESPTab:AddToggle('TracerESPEnabled', {
    Text = 'Tracer',
    Default = false, 
    Tooltip = 'Tracer ESP Enabled', 
})

Toggles.TracerESPEnabled:OnChanged(function()
    getgenv().taffy_esp.tracer.enabled = Toggles.TracerESPEnabled.Value
end)

Toggles.TracerESPEnabled:AddColorPicker('TracerESPColor', {
    Default = Color3.fromRGB(0,255,0),
    Title = 'Tracer ESP Color'
})

Options.TracerESPColor:OnChanged(function()
    getgenv().taffy_esp.tracer.color = Options.TracerESPColor.Value
end)

ESPTab:AddToggle('UnlockedTracerEnabled', {
    Text = 'Unlock Tracer',
    Default = false, 
    Tooltip = 'Connects Tracer to Mouse', 
})

Toggles.UnlockedTracerEnabled:OnChanged(function()
    getgenv().taffy_esp.tracer.unlocktracers = Toggles.UnlockedTracerEnabled.Value
end)

ESPTab:AddToggle('NameESPEnabled', {
    Text = 'Name',
    Default = false, 
    Tooltip = 'Name ESP Enabled', 
})

Toggles.NameESPEnabled:OnChanged(function()
    getgenv().taffy_esp.name.enabled = Toggles.NameESPEnabled.Value
end)

Toggles.NameESPEnabled:AddColorPicker('NameESPColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Name ESP Color'
})

Options.NameESPColor:OnChanged(function()
    getgenv().taffy_esp.name.color = Options.NameESPColor.Value
end)

ESPTab:AddToggle('ToolESPEnabled', {
    Text = 'Held Tool',
    Default = false, 
    Tooltip = 'Held Tool ESP Enabled', 
})

Toggles.ToolESPEnabled:OnChanged(function()
    getgenv().taffy_esp.Toolsshow.enable = Toggles.ToolESPEnabled.Value
end)

Toggles.ToolESPEnabled:AddColorPicker('ToolESPColor', {
    Default = Color3.fromRGB(255,255,255),
    Title = 'Held Tool ESP Color'
})

Options.ToolESPColor:OnChanged(function()
    getgenv().taffy_esp.Toolsshow.color = Options.ToolESPColor.Value
end)

WorldTab:AddLabel('Ambient'):AddColorPicker('AmbientColorPicker', {
    Default = Color3.fromRGB(0,0,0),
    Title = 'Ambient', 
})

Options.AmbientColorPicker:OnChanged(function()
    
    if AmbientRainbowMode == true then

    else
        game.Lighting.Ambient = Options.AmbientColorPicker.Value
    end
end)

WorldTab:AddToggle('RainbowAmbient', {
    Text = 'Rainbow Ambient',
    Default = false, 
    Tooltip = 'Rainbow Ambient Enabled', 
})

Toggles.RainbowAmbient:OnChanged(function()
    AmbientRainbowMode = Toggles.RainbowAmbient.Value
    if Toggles.RainbowAmbient.Value then
        while Toggles.RainbowAmbient.Value do
            wait()
            game:GetService("Lighting").Ambient  = Color3.new(255/255,0/255,0/255)
            for i = 0,255,10 do
             wait()
             game:GetService("Lighting").Ambient = Color3.new(255/255,i/255,0/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").Ambient = Color3.new(i/255,255/255,0/255)
            end
            for i = 0,255,10 do
               wait()
               game:GetService("Lighting").Ambient = Color3.new(0/255,255/255,i/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").Ambient = Color3.new(0/255,i/255,255/255)
            end
            for i = 0,255,10 do
                wait()
                game:GetService("Lighting").Ambient = Color3.new(i/255,0/255,255/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").Ambient = Color3.new(255/255,0/255,i/255)
            end
            if Toggles.RainbowAmbient.Value == false then break end
        end
    end
end)

local AmbientReset = WorldTab:AddButton('Reset to Default', function()
    Options.AmbientColorPicker:SetValueRGB(Color3.fromRGB(0,0,0))
end)

WorldTab:AddLabel('Outdoor Ambient'):AddColorPicker('OutdoorAmbientColor', {
    Default = Color3.fromRGB(152, 152, 146),
    Title = 'Outdoor Ambient', 
})

Options.OutdoorAmbientColor:OnChanged(function()
    if OutdoorAmbientRainbowMode then
    else
        game.Lighting.OutdoorAmbient = Options.OutdoorAmbientColor.Value
    end
end)

WorldTab:AddToggle('RainbowOutdoorAmbient', {
    Text = 'Rainbow Outdoor',
    Default = false, 
    Tooltip = 'Rainbow Outdoor Ambient Enabled', 
})

Toggles.RainbowOutdoorAmbient:OnChanged(function()
    OutdoorAmbientRainbowMode = Toggles.RainbowOutdoorAmbient.Value
    if Toggles.RainbowOutdoorAmbient.Value then
        while Toggles.RainbowOutdoorAmbient.Value do
            wait()
            game:GetService("Lighting").OutdoorAmbient  = Color3.new(255/255,0/255,0/255)
            for i = 0,255,10 do
             wait()
             game:GetService("Lighting").OutdoorAmbient = Color3.new(255/255,i/255,0/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").OutdoorAmbient = Color3.new(i/255,255/255,0/255)
            end
            for i = 0,255,10 do
               wait()
               game:GetService("Lighting").OutdoorAmbient = Color3.new(0/255,255/255,i/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").OutdoorAmbient = Color3.new(0/255,i/255,255/255)
            end
            for i = 0,255,10 do
                wait()
                game:GetService("Lighting").OutdoorAmbient = Color3.new(i/255,0/255,255/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").OutdoorAmbient = Color3.new(255/255,0/255,i/255)
            end
            if Toggles.RainbowOutdoorAmbient.Value == false then break end
        end
    end
end)

local OutdoorAmbientReset = WorldTab:AddButton('Reset to Default', function()
    Options.OutdoorAmbientColor:SetValueRGB(Color3.fromRGB(152, 152, 146))
end)

WorldTab:AddSlider('FogEndSlider', {
    Text = 'Fog End',

    Default = 750,
    Min = 1,
    Max = 1000,
    Rounding = 1,

    Compact = false,
})

Options.FogEndSlider:OnChanged(function()
    game.Lighting.FogEnd = Options.FogEndSlider.Value
end)

WorldTab:AddLabel('Fog Color'):AddColorPicker('FogColorColorPicker', {
    Default = Color3.fromRGB(100, 87, 72),
    Title = 'Fog Color', 
})

Options.FogColorColorPicker:OnChanged(function()
    if FogRainbowMode then
    else
        game.Lighting.FogColor = Options.FogColorColorPicker.Value
    end
end)

WorldTab:AddToggle('RainbowFogColor', {
    Text = 'Rainbow Outdoor',
    Default = false, 
    Tooltip = 'Rainbow Outdoor Ambient Enabled', 
})

Toggles.RainbowFogColor:OnChanged(function()
    FogRainbowMode = Toggles.RainbowFogColor.Value
    if Toggles.RainbowFogColor.Value then
        while Toggles.RainbowFogColor.Value do
            wait()
            game:GetService("Lighting").FogColor  = Color3.new(255/255,0/255,0/255)
            for i = 0,255,10 do
             wait()
             game:GetService("Lighting").FogColor = Color3.new(255/255,i/255,0/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").FogColor = Color3.new(i/255,255/255,0/255)
            end
            for i = 0,255,10 do
               wait()
               game:GetService("Lighting").FogColor = Color3.new(0/255,255/255,i/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").FogColor = Color3.new(0/255,i/255,255/255)
            end
            for i = 0,255,10 do
                wait()
                game:GetService("Lighting").FogColor = Color3.new(i/255,0/255,255/255)
            end
            for i = 255,0,-10 do
                wait()
                game:GetService("Lighting").FogColor = Color3.new(255/255,0/255,i/255)
            end
            if Toggles.RainbowFogColor.Value == false then break end
        end
    end
end)

local ResetFogEnd = WorldTab:AddButton('Reset to Default', function()
    Options.FogEndSlider:SetValue(500)
    Options.FogColorColorPicker:SetValueRGB(Color3.fromRGB(100, 87, 72))
end)

WorldTab:AddToggle('GlobalShadowsEnabled', {
    Text = 'Global Shadows',
    Default = true, 
    Tooltip = 'Global Shadows Enabled', 
})

Toggles.GlobalShadowsEnabled:OnChanged(function()
    game.Lighting.GlobalShadows = Toggles.GlobalShadowsEnabled.Value
end)
WorldTab:AddSlider('Saturation', {
    Text = 'Saturation',

    Default = 0,
    Min = 0,
    Max = 10,
    Rounding = 1,

    Compact = false,
})

Options.Saturation:OnChanged(function()
                        local ColorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect")
ColorCorrection.Saturation = Options.Saturation.Value
end)
WorldTab:AddSlider('Contrast', {
    Text = 'Contrast',

    Default = 0.1,
    Min = 0,
    Max = 10,
    Rounding = 1,

    Compact = false,
})

Options.Contrast:OnChanged(function()
    local ColorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect")
ColorCorrection.Contrast = Options.Contrast.Value
end)

BulletTab:AddToggle('BulletTracer', {
    Text = 'Enabled',
    Default = false, 
    Tooltip = 'Tracers Enabled', 
})

Toggles.BulletTracer:OnChanged(function()
    ruby.Visuals.Local.BulletTracer.Enabled = Toggles.BulletTracer.Value
end)

    bullet_tracer_color = Color3.fromRGB(230, 230, 250)
    
    function GetGun()
        if game.Players.LocalPlayer.Character then
            for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
                if v:FindFirstChild 'Ammo' then
                    return v
                end
            end
        end
        return nil
    end
    
    local Services = {
        Players = game:GetService("Players"),
        UserInputService = game:GetService("UserInputService"),
        RunService = game:GetService("RunService"),
    }
    
    local Local = {
        Player = Services.Players.LocalPlayer,
        Mouse = Services.Players.LocalPlayer:GetMouse(),
    }
    local Other = {
        Camera = workspace.CurrentCamera,
        BeamPart = Instance.new("Part", workspace)
    }
    
    Other.BeamPart.Name = "BeamPart"
    Other.BeamPart.Transparency = 1
    local Settings = {
        StartColor = bullet_tracer_color,
        EndColor = bullet_tracer_color,
        StartWidth = 3,
        EndWidth = 3,
        ShowImpactPoint = false,
        ImpactTransparency = 0.5,
        ImpactColor = Color3.new(1, 1, 1),
        Time = 1,
    }
    game:GetService "RunService".Heartbeat:Connect(function()
        if game:GetService("Workspace").Ignored:FindFirstChild 'BULLET_RAYS' and BulletTracers then
            game:GetService("Workspace").Ignored.BULLET_RAYS:Destroy()
        end
    end)
    local funcs = {}
    Local.Mouse.TargetFilter = Other.BeamPart
    function funcs:Beam(v1, v2)
        v2 = Vector3.new(v2.X - 0.1, v2.Y + 0.2, v2.Z)
        local colorSequence = ColorSequence.new({
            ColorSequenceKeypoint.new(0, bullet_tracer_color),
            ColorSequenceKeypoint.new(1, bullet_tracer_color),
        })
        local Part = Instance.new("Part", Other.BeamPart)
        Part.Size = Vector3.new(0, 0, 0)
        Part.Massless = true
        Part.Transparency = 1
        Part.CanCollide = false
        Part.Position = v1
        Part.Anchored = true
        local Attachment = Instance.new("Attachment", Part)
        local Part2 = Instance.new("Part", Other.BeamPart)
        Part2.Size = Vector3.new(0, 0, 0)
        Part2.Transparency = 0
        Part2.CanCollide = false
        Part2.Position = v2
        Part2.Anchored = true
        Part2.Material = Enum.Material.ForceField
        Part2.Color = Settings.ImpactColor
        Part2.Massless = true
        local Attachment2 = Instance.new("Attachment", Part2)
        local Beam = Instance.new("Beam", Part)
        Beam.FaceCamera = true
        Beam.Color = colorSequence
        Beam.Attachment0 = Attachment
        Beam.Attachment1 = Attachment2
        Beam.LightEmission = 6
        Beam.LightInfluence = 1
        Beam.Width0 = Settings.StartWidth
        Beam.Width1 = Settings.EndWidth
        Beam.Texture = "http://www.roblox.com/asset/?id=9150663556"
        Beam.TextureSpeed = 2
        Beam.TextureLength = 1
        delay(Settings.Time, function()
            Part:Destroy()
            Part2:Destroy()
        end)
    end
    
    spawn(function()
        while task.wait(0.5) do
            gun = GetGun()
            if gun then
                LastAmmo = gun.Ammo.Value
                gun.Ammo:GetPropertyChangedSignal("Value"):Connect(function()
                    if BulletTracers and gun.Ammo.Value < LastAmmo then
                        LastAmmo = gun.Ammo.Value
                        funcs:Beam(gun.Handle.Position, Local.Mouse.hit.p)
                    end
                end)
            end
        end
    end)

BulletTab:AddLabel("(recommended for camlock)")

TeleportTab:AddDropdown('SchoolDropdown', {
    Values = { 'None','Food', 'Roof', 'Secret Room' },
    Default = 1,
    Multi = false, 

    Text = 'School',
    Tooltip = 'School Tps',
})

Options.SchoolDropdown:OnChanged(function()
    if Options.SchoolDropdown.Value == "None" then
    elseif Options.SchoolDropdown.Value == "Food" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-613.674194, 21.8749924, 289.857483, 0.00497477828, 2.20831442e-08, -0.999987602, -3.01110035e-08, 1, 2.19336211e-08, 0.999987602, 3.00015159e-08, 0.00497477828)
    elseif Options.SchoolDropdown.Value == "Secret Room" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-503.606995, 21.8749924, 361.749969, 0.999836385, -4.32269722e-08, -0.0180903766, 4.39084253e-08, 1, 3.72720521e-08, 0.0180903766, -3.80602749e-08, 0.999836385)
    elseif Options.SchoolDropdown.Value == "Roof" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-606.53656, 68.6249771, 325.997162, 0.99997282, 3.51442764e-10, 0.00737056695, -3.13645859e-10, 1, -5.12924192e-09, -0.00737056695, 5.12679055e-09, 0.99997282)
    end
end)

TeleportTab:AddDropdown('BankDropdown', {
    Values = { 'None','Food', 'Roof', 'Vault' },
    Default = 1,
    Multi = false, 

    Text = 'Bank',
    Tooltip = 'Bank Tps',
})

Options.BankDropdown:OnChanged(function()
    if Options.BankDropdown.Value == "None" then
    elseif Options.BankDropdown.Value == "Food" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-334.105621, 23.6826458, -297.371765, 0.0062069688, 8.89299017e-08, -0.999980748, 1.73607013e-08, 1, 8.9039375e-08, 0.999980748, -1.79130311e-08, 0.0062069688)
    elseif Options.BankDropdown.Value == "Vault" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-508.115051, 23.169693, -284.901337, -0.0288586095, -4.23028865e-08, -0.999583483, -4.83239475e-08, 1, -4.0925368e-08, 0.999583483, 4.71227715e-08, -0.0288586095)
    elseif Options.BankDropdown.Value == "Roof" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-459.32785, 39.0389023, -285.086548, 0.0124173071, 5.90856395e-08, -0.999922931, 3.85150489e-09, 1, 5.91380243e-08, 0.999922931, -4.58554306e-09, 0.0124173071)
    end
end)

TeleportTab:AddDropdown('UphillTps', {
    Values = { 'None','Food', 'Guns', 'Uphill Building 1','Uphill Building 2','Armor' },
    Default = 1,
    Multi = false, 

    Text = 'Uphill',
    Tooltip = 'Uphill Tps',
})

Options.UphillTps:OnChanged(function()
    if Options.UphillTps.Value == "None" then
    elseif Options.UphillTps.Value == "Food" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(299.117859, 49.2826538, -613.93158, 0.999884248, -2.11976445e-08, -0.015215965, 2.13970885e-08, 1, 1.29448381e-08, 0.015215965, -1.32689166e-08, 0.999884248)
    elseif Options.UphillTps.Value == "Guns" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(481.662781, 48.0704918, -622.017944, -0.999999166, 8.56621298e-08, 0.00129488122, 8.56506901e-08, 1, -8.88794016e-09, -0.00129488122, -8.77702444e-09, -0.999999166)
    elseif Options.UphillTps.Value == "Uphill Building 1" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(435.492004, 106.683769, -627.779114, -0.999886215, 4.09484855e-08, -0.0150852418, 4.09440126e-08, 1, 6.05427153e-10, 0.0150852418, -1.22920268e-11, -0.999886215)
    elseif Options.UphillTps.Value == "Uphill Building 2" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(300.213928, 106.03389, -620.259521, -0.999988019, 1.25798518e-08, -0.00488910545, 1.23825759e-08, 1, 4.03804208e-08, 0.00488910545, 4.03193994e-08, -0.999988019)
    elseif Options.UphillTps.Value == "Armor" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(533.781738, 50.3253212, -637.361084, 0.0147596924, -1.06152655e-07, 0.999891043, -2.64739004e-08, 1, 1.06555007e-07, -0.999891043, -2.80437362e-08, 0.0147596924)
    end
end)

TeleportTab:AddDropdown('DownhillTps', {
    Values = { 'None','Guns','Armor','Admin Base' },
    Default = 1,
    Multi = false, 

    Text = 'Downhill',
    Tooltip = 'Downhill Tps',
})

Options.DownhillTps:OnChanged(function()
    if Options.DownhillTps.Value == "None" then
    elseif Options.DownhillTps.Value == "Guns" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-581.334473, 8.31477833, -736.237427, -0.00332057965, -4.02167544e-08, -0.999994516, -5.74397596e-08, 1, -4.00262437e-08, 0.999994516, 5.73065329e-08, -0.00332057965)
    elseif Options.DownhillTps.Value == "Armor" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-604.672913, 10.3496885, -788.588745, -0.0184768867, -9.57051682e-09, 0.999829292, -3.11832942e-08, 1, 8.99588226e-09, -0.999829292, -3.10117549e-08, -0.0184768867)
    elseif Options.DownhillTps.Value == "Admin Base" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-797.611328, -39.6492157, -886.291382, 0.0349296406, -6.03186034e-09, 0.999389768, -1.15090231e-08, 1, 6.43779474e-09, -0.999389768, -1.17268701e-08, 0.0349296406)
    end
end)

TeleportTab:AddDropdown('CasinoTps', {
    Values = { 'None','Popcorn','DB','Casino' },
    Default = 1,
    Multi = false, 

    Text = 'Casino',
    Tooltip = 'Casino Tps',
})

Options.CasinoTps:OnChanged(function()
    if Options.CasinoTps.Value == "None" then
    elseif Options.CasinoTps.Value == "Popcorn" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-989.919678, 24.600008, -152.482224, 0.99982506, 1.5004666e-08, 0.0187029168, -1.51050052e-08, 1, 5.22361621e-09, -0.0187029168, -5.50521007e-09, 0.99982506)
    elseif Options.CasinoTps.Value == "DB" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1039.74451, 21.7499943, -260.811493, -0.999998271, 3.43565993e-08, 0.0018673077, 3.42738211e-08, 1, -4.4362519e-08, -0.0018673077, -4.42984422e-08, -0.999998271)
    elseif Options.CasinoTps.Value == "Casino" then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-866.869263, 21.7499943, -116.072456, -0.99939853, -1.97582839e-09, 0.0346787088, 1.85263072e-09, 1, 1.10365839e-07, -0.0346787088, 1.103637e-07, -0.99939853)
    end
end)

FlyTab:AddToggle('FlyTggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable Fly',
})

Toggles.FlyTggle:OnChanged(function()
    if Toggles.FlyTggle.Value == true then
        FlyLoop = game:GetService("RunService").Stepped:Connect(function()
            spawn(function()
                pcall(function()
                    local speed = FlySpeed
                    local velocity = Vector3.new(0, 1, 0)
                    local UserInputService = game:GetService("UserInputService")

                    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                        velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.lookVector * speed)
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                        velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.rightVector * -speed)
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                        velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.lookVector * -speed)
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                        velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.rightVector * speed)
                    end
                    
                    LocalPlayer.Character.HumanoidRootPart.Velocity = velocity
                    LocalPlayer.Character.Humanoid:ChangeState("Freefall")
                end)
            end)
        end)
    elseif Toggles.FlyTggle.Value == false and FlyLoop then
        FlyLoop:Disconnect()
        LocalPlayer.Character.Humanoid:ChangeState("Landing")
    end
end)

Toggles.FlyTggle:AddKeyPicker('FlyBind', {
    Default = 'None', 
    SyncToggleState = true, 

    Mode = 'Toggle',

    Text = 'Fly', 
    NoUI = false,
})

FlyTab:AddSlider('FlySepedSlider', {
    Text = 'Speed',

    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 2,

    Compact = false,
})

Options.FlySepedSlider:OnChanged(function()
    FlySpeed = Options.FlySepedSlider.Value*50
end)

AnimationsTab:AddButton('Perm Animation Pack', function()
    repeat
        wait()
    until game:IsLoaded() and game.Players.LocalPlayer.Character:FindFirstChild("FULLY_LOADED_CHAR") and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPack")
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Lean") then
        game.ReplicatedStorage.ClientAnimations.Lean:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Lay") then
        game.ReplicatedStorage.ClientAnimations.Lay:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Dance1") then
        game.ReplicatedStorage.ClientAnimations.Dance1:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Dance2") then
        game.ReplicatedStorage.ClientAnimations.Dance2:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Greet") then
        game.ReplicatedStorage.ClientAnimations.Greet:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Chest Pump") then
        game.ReplicatedStorage.ClientAnimations["Chest Pump"]:Destroy()
    end
    
    if game.ReplicatedStorage.ClientAnimations:FindFirstChild("Praying") then
        game.ReplicatedStorage.ClientAnimations.Praying:Destroy()
    end
    
    local Animations = game.ReplicatedStorage.ClientAnimations
    
    local LeanAnimation = Instance.new("Animation", Animations)
    LeanAnimation.Name = "Lean"
    LeanAnimation.AnimationId = "rbxassetid://3152375249"
    
    local LayAnimation = Instance.new("Animation", Animations)
    LayAnimation.Name = "Lay"
    LayAnimation.AnimationId = "rbxassetid://3152378852"
    
    local Dance1Animation = Instance.new("Animation", Animations)
    Dance1Animation.Name = "Dance1"
    Dance1Animation.AnimationId = "rbxassetid://3189773368"
    
    local Dance2Animation = Instance.new("Animation", Animations)
    Dance2Animation.Name = "Dance2"
    Dance2Animation.AnimationId = "rbxassetid://3189776546"
    
    local GreetAnimation = Instance.new("Animation", Animations)
    GreetAnimation.Name = "Greet"
    GreetAnimation.AnimationId = "rbxassetid://3189777795"
    
    local ChestPumpAnimation = Instance.new("Animation", Animations)
    ChestPumpAnimation.Name = "Chest Pump"
    ChestPumpAnimation.AnimationId = "rbxassetid://3189779152"
    
    local PrayingAnimation = Instance.new("Animation", Animations)
    PrayingAnimation.Name = "Praying"
    PrayingAnimation.AnimationId = "rbxassetid://3487719500"
    
    function AnimationPack(Character)
        Character:WaitForChild'Humanoid'
        repeat
            wait()
        until game.Players.LocalPlayer.Character:FindFirstChild("FULLY_LOADED_CHAR") and game.Players.LocalPlayer.PlayerGui.MainScreenGui:FindFirstChild("AnimationPack")
    
        local AnimationPack = game:GetService("Players").LocalPlayer.PlayerGui.MainScreenGui.AnimationPack
        local ScrollingFrame = AnimationPack.ScrollingFrame
        local CloseButton = AnimationPack.CloseButton
    
        local Lean = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(LeanAnimation)
    
        local Lay = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(LayAnimation)
    
        local Dance1 = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(Dance1Animation)
    
        local Dance2 = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(Dance2Animation)
    
        local Greet = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(GreetAnimation)
    
        local ChestPump = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(ChestPumpAnimation)
    
        local Praying = game:GetService("Players").LocalPlayer.Character.Humanoid:LoadAnimation(PrayingAnimation)
    
        AnimationPack.Visible = true
    
        AnimationPack.ScrollingFrame.UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Lean" then
                    v.Name = "LeanButton"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Lay" then
                    v.Name = "LayButton"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Dance1" then
                    v.Name = "Dance1Button"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Dance2" then
                    v.Name = "Dance2Button"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Greet" then
                    v.Name = "GreetButton"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Chest Pump" then
                    v.Name = "ChestPumpButton"
                end
            end
        end
    
        for i,v in pairs(ScrollingFrame:GetChildren()) do
            if v.Name == "TextButton" then
                if v.Text == "Praying" then
                    v.Name = "PrayingButton"
                end
            end
        end
    
        function Stop()
            Lean:Stop()
            Lay:Stop()
            Dance1:Stop()
            Dance2:Stop()
            Greet:Stop()
            ChestPump:Stop()
            Praying:Stop()
        end
    
        local LeanTextButton = ScrollingFrame.LeanButton
        local LayTextButton = ScrollingFrame.LayButton
        local Dance1TextButton = ScrollingFrame.Dance1Button
        local Dance2TextButton = ScrollingFrame.Dance2Button
        local GreetTextButton = ScrollingFrame.GreetButton
        local ChestPumpTextButton = ScrollingFrame.ChestPumpButton
        local PrayingTextButton = ScrollingFrame.PrayingButton
    
        AnimationPack.MouseButton1Click:Connect(function()
            if ScrollingFrame.Visible == false then
                ScrollingFrame.Visible = true
                CloseButton.Visible = true
            end
        end)
        CloseButton.MouseButton1Click:Connect(function()
            if ScrollingFrame.Visible == true then
                ScrollingFrame.Visible = false
                CloseButton.Visible = false
            end
        end)
        LeanTextButton.MouseButton1Click:Connect(function()
            Stop()
            Lean:Play()
        end)
        LayTextButton.MouseButton1Click:Connect(function()
            Stop()
            Lay:Play()
        end)
        Dance1TextButton.MouseButton1Click:Connect(function()
            Stop()
            Dance1:Play()
        end)
        Dance2TextButton.MouseButton1Click:Connect(function()
            Stop()
            Dance2:Play()
        end)
        GreetTextButton.MouseButton1Click:Connect(function()
            Stop()
            Greet:Play()
        end)
        ChestPumpTextButton.MouseButton1Click:Connect(function()
            Stop()
            ChestPump:Play()
        end)
        PrayingTextButton.MouseButton1Click:Connect(function()
            Stop()
            Praying:Play()
        end)
    
        game:GetService("Players").LocalPlayer.Character.Humanoid.Running:Connect(function()
            Stop()
        end)
    
        game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
            Stop()
        end)
    end
    AnimationPack(game.Players.LocalPlayer.Character)
    game.Players.LocalPlayer.CharacterAdded:Connect(AnimationPack)
end)



AnimationsTab:AddDropdown('RunAnimations', {
    Values = { 'None','Rthro','Werewolf','Zombie','Ninja','Toy','Superhero','OldSchool','Cartoony','Stylish','Vampire','Bubbly','Robot','Astronaut', },
    Default = 1,
    Multi = false, 

    Text = 'Run',
})

Options.RunAnimations:OnChanged(function()
    ChangeAnimHook = game:GetService("RunService").Stepped:Connect(function ()
        if Options.RunAnimations.Value == "None" then
        elseif Options.RunAnimations.Value == "Rthro" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=2510198475"
        elseif Options.RunAnimations.Value == "Werewolf" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=1083216690"
        elseif Options.RunAnimations.Value == "Zombie" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        elseif Options.RunAnimations.Value == "Ninja" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=656118852"
        elseif Options.RunAnimations.Value == "Toy" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=782842708"
        elseif Options.RunAnimations.Value == "Superhero" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616117076"
        elseif Options.RunAnimations.Value == "OldSchool" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=5319844329"
        elseif Options.RunAnimations.Value == "Cartoony" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=742638842"
        elseif Options.RunAnimations.Value == "Stylish" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616140816"
        elseif Options.RunAnimations.Value == "Vampire" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=1083462077"
        elseif Options.RunAnimations.Value == "Bubbly" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=910025107"
        elseif Options.RunAnimations.Value == "Robot" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616091570"
        elseif Options.RunAnimations.Value == "Astronaut" then
            LocalPlayer.Character.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=891636393"
        end
    end)
end)

AnimationsTab:AddDropdown('JumpAnimations', {
    Values = { 'None','Rthro','Werewolf','Zombie','Ninja','Toy','Superhero','OldSchool','Cartoony','Stylish','Vampire','Bubbly','Robot','Astronaut' },
    Default = 1,
    Multi = false, 

    Text = 'Jump',
})

Options.JumpAnimations:OnChanged(function()
    ChangeJumpAnimHook = game:GetService("RunService").Stepped:Connect(function ()
        if Options.JumpAnimations.Value == "None" then
        elseif Options.JumpAnimations.Value == "Rthro" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=2510197830"
        elseif Options.JumpAnimations.Value == "Werewolf" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=1083218792"
        elseif Options.JumpAnimations.Value == "Zombie" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=616161997"
        elseif Options.JumpAnimations.Value == "Ninja" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=656117878"
        elseif Options.JumpAnimations.Value == "Toy" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=782847020"
        elseif Options.JumpAnimations.Value == "Superhero" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=616115533"
        elseif Options.JumpAnimations.Value == "OldSchool" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=5319841935"
        elseif Options.JumpAnimations.Value == "Cartoony" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=742637942"
        elseif Options.JumpAnimations.Value == "Stylish" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=616139451"
        elseif Options.JumpAnimations.Value == "Vampire" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=1083455352"
        elseif Options.JumpAnimations.Value == "Bubbly" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=910016857"
        elseif Options.JumpAnimations.Value == "Robot" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=616090535"
        elseif Options.JumpAnimations.Value == "Astronaut" then
            LocalPlayer.Character.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=891627522"
        end
    end)
end)

AnimationsTab:AddDropdown('FallAnimations', {
    Values = { 'None','Rthro','Werewolf','Zombie','Ninja','Toy','Superhero','OldSchool','Cartoony','Stylish','Vampire','Bubbly','Robot','Astronaut','Mage' },
    Default = 1,
    Multi = false, 

    Text = 'Fall',
})

Options.FallAnimations:OnChanged(function()
    ChangeFallAnimHook = game:GetService("RunService").Stepped:Connect(function ()
        if Options.FallAnimations.Value == "None" then
        elseif Options.FallAnimations.Value == "Rthro" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=2510195892"
        elseif Options.FallAnimations.Value == "Werewolf" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=1083189019"
        elseif Options.FallAnimations.Value == "Zombie" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=616157476"
        elseif Options.FallAnimations.Value == "Ninja" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=656115606"
        elseif Options.FallAnimations.Value == "Toy" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=782846423"
        elseif Options.FallAnimations.Value == "Superhero" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=616115533"
        elseif Options.FallAnimations.Value == "OldSchool" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=5319839762"
        elseif Options.FallAnimations.Value == "Cartoony" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=742640026"
        elseif Options.FallAnimations.Value == "Stylish" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=616134815"
        elseif Options.FallAnimations.Value == "Vampire" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=1083443587"
        elseif Options.FallAnimations.Value == "Bubbly" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=910001910"
        elseif Options.FallAnimations.Value == "Robot" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=616087089"
        elseif Options.FallAnimations.Value == "Astronaut" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=891617961"
        elseif Options.FallAnimations.Value == "Mage" then
            LocalPlayer.Character.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
        end
    end)
end)
AnimationsTab:AddLabel("(dont change anim while moving)")

FunTab:AddButton('Invis Ball', function()
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    
    local SPEED_MULTIPLIER = 30
    local JUMP_POWER = 60
    local JUMP_GAP = 0.3
    
    local character = game.Players.LocalPlayer.Character
    
    for i,v in ipairs(character:GetDescendants()) do
        if v:IsA("BasePart") then
            v.CanCollide = false
        end
    end
    
    local ball = character.HumanoidRootPart
    ball.Shape = Enum.PartType.Ball
    ball.Size = Vector3.new(5,5,5)
    local humanoid = character:WaitForChild("Humanoid")
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character}
    
    local tc = RunService.RenderStepped:Connect(function(delta)
        ball.CanCollide = true
        humanoid.PlatformStand = true
        if UserInputService:GetFocusedTextBox() then return end
        if UserInputService:IsKeyDown("W") then
            ball.RotVelocity -= Camera.CFrame.RightVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("A") then
            ball.RotVelocity -= Camera.CFrame.LookVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("S") then
            ball.RotVelocity += Camera.CFrame.RightVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("D") then
            ball.RotVelocity += Camera.CFrame.LookVector * delta * SPEED_MULTIPLIER
        end
    end)
    
    UserInputService.JumpRequest:Connect(function()
        local result = workspace:Raycast(
            ball.Position,
            Vector3.new(
                0,
                -((ball.Size.Y/2)+JUMP_GAP),
                0
            ),
            params
        )
        if result then
            ball.Velocity = ball.Velocity + Vector3.new(0,JUMP_POWER,0)
        end
    end)
    
    Camera.CameraSubject = ball
    humanoid.Died:Connect(function() tc:Disconnect() end)
end)

FunTab:AddButton('Client-Sided Headless', function()
    game.Players.LocalPlayer.Character.Head.Transparency = 1
    game.Players.LocalPlayer.Character.Head.Transparency = 1
    for i,v in pairs(game.Players.LocalPlayer.Character.Head:GetChildren()) do
    if (v:IsA("Decal")) then
    v.Transparency = 1
    end
    end
end)

FunTab:AddButton('Client-Sided Korblox', function()
    local ply = game.Players.LocalPlayer
    local chr = ply.Character
    chr.RightLowerLeg.MeshId = "902942093"
    chr.RightLowerLeg.Transparency = "1"
    chr.RightUpperLeg.MeshId = "http://www.roblox.com/asset/?id=902942096"
    chr.RightUpperLeg.TextureID = "http://roblox.com/asset/?id=902843398"
    chr.RightFoot.MeshId = "902942089"
    chr.RightFoot.Transparency = "1"    
end)

FunTab:AddButton('Grav Gun (Works Sometimes)', function()
    function sandbox(var,func)
        local env = getfenv(func)
        local newenv = setmetatable({},{
            __index = function(self,k)
                if k=="script" then
                    return var
                else
                    return env[k]
                end
            end,
        })
        setfenv(func,newenv)
        return func
    end
    cors = {}
    mas = Instance.new("Model",game:GetService("Lighting"))
    Tool0 = Instance.new("Tool")
    Part1 = Instance.new("Part")
    CylinderMesh2 = Instance.new("CylinderMesh")
    Part3 = Instance.new("Part")
    LocalScript4 = Instance.new("LocalScript")
    Script5 = Instance.new("Script")
    LocalScript6 = Instance.new("LocalScript")
    Script7 = Instance.new("Script")
    LocalScript8 = Instance.new("LocalScript")
    Part9 = Instance.new("Part")
    Script10 = Instance.new("Script")
    Part11 = Instance.new("Part")
    Script12 = Instance.new("Script")
    Part13 = Instance.new("Part")
    Script14 = Instance.new("Script")
    Tool0.Name = "Telekinesis Gun"
    Tool0.Parent = mas
    Tool0.CanBeDropped = false
    Part1.Name = "Handle"
    Part1.Parent = Tool0
    Part1.Material = Enum.Material.Neon
    Part1.BrickColor = BrickColor.new("Cyan")
    Part1.Transparency = 1
    Part1.Rotation = Vector3.new(0, 15.4200001, 0)
    Part1.CanCollide = false
    Part1.FormFactor = Enum.FormFactor.Custom
    Part1.Size = Vector3.new(1, 0.400000036, 0.300000012)
    Part1.CFrame = CFrame.new(-55.2695465, 0.696546972, 0.383156985, 0.96399641, -4.98074878e-05, 0.265921414, 4.79998416e-05, 1, 1.32960558e-05, -0.265921414, -5.30653779e-08, 0.96399641)
    Part1.BottomSurface = Enum.SurfaceType.Smooth
    Part1.TopSurface = Enum.SurfaceType.Smooth
    Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Part1.Position = Vector3.new(-55.2695465, 0.696546972, 0.383156985)
    Part1.Orientation = Vector3.new(0, 15.4200001, 0)
    Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    CylinderMesh2.Parent = Part1
    CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
    CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
    Part3.Name = "Shoot"
    Part3.Parent = Tool0
    Part3.Material = Enum.Material.Neon
    Part3.BrickColor = BrickColor.new("Cyan")
    Part3.Reflectance = 0.30000001192093
    Part3.Transparency = 1
    Part3.Rotation = Vector3.new(90.9799957, 0.25999999, -91.409996)
    Part3.CanCollide = false
    Part3.FormFactor = Enum.FormFactor.Custom
    Part3.Size = Vector3.new(0.200000003, 0.25, 0.310000032)
    Part3.CFrame = CFrame.new(-54.7998123, 0.774299085, -0.757350147, -0.0245519895, 0.99968797, 0.00460194098, 0.0169109926, 0.00501798885, -0.999844491, -0.999555528, -0.0244703442, -0.0170289185)
    Part3.BottomSurface = Enum.SurfaceType.Smooth
    Part3.TopSurface = Enum.SurfaceType.Smooth
    Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Part3.Position = Vector3.new(-54.7998123, 0.774299085, -0.757350147)
    Part3.Orientation = Vector3.new(88.9899979, 164.87999, 73.4700012)
    Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    LocalScript4.Parent = Tool0
    table.insert(cors,sandbox(LocalScript4,function()
    -- Variables for services
    local render = game:GetService("RunService").RenderStepped
    local contextActionService = game:GetService("ContextActionService")
    local userInputService = game:GetService("UserInputService")
    
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()
    local Tool = script.Parent
    
    -- Variables for Module Scripts
    local screenSpace = require(Tool:WaitForChild("ScreenSpace"))
    
    local connection
    -- Variables for character joints
    
    local neck, shoulder, oldNeckC0, oldShoulderC0 
    
    local mobileShouldTrack = true
    
    -- Thourough check to see if a character is sitting
    local function amISitting(character)
        local t = character.Torso
        for _, part in pairs(t:GetConnectedParts(true)) do
            if part:IsA("Seat") or part:IsA("VehicleSeat") then
                return true
            end
        end
    end
    
    -- Function to call on renderstepped. Orients the character so it is facing towards
    -- the player mouse's position in world space. If character is sitting then the torso
    -- should not track
    local function frame(mousePosition)
        -- Special mobile consideration. We don't want to track if the user was touching a ui
        -- element such as the movement controls. Just return out of function if so to make sure
        -- character doesn't track
        if not mobileShouldTrack then return end
        
        -- Make sure character isn't swiming. If the character is swimming the following code will
        -- not work well; the character will not swim correctly. Besides, who shoots underwater?
        if player.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then
            local torso = player.Character.Torso
            local head = player.Character.Head
            
            local toMouse = (mousePosition - head.Position).unit
            local angle = math.acos(toMouse:Dot(Vector3.new(0,1,0)))
            
            local neckAngle = angle
        
            -- Limit how much the head can tilt down. Too far and the head looks unnatural
            if math.deg(neckAngle) > 110 then
                neckAngle = math.rad(110)
            end
            neck.C0 = CFrame.new(0,1,0) * CFrame.Angles(math.pi - neckAngle,math.pi,0)
            
            -- Calculate horizontal rotation
            local arm = player.Character:FindFirstChild("Right Arm")
            local fromArmPos = torso.Position + torso.CFrame:vectorToWorldSpace(Vector3.new(
                torso.Size.X/2 + arm.Size.X/2, torso.Size.Y/2 - arm.Size.Z/2, 0))
            local toMouseArm = ((mousePosition - fromArmPos) * Vector3.new(1,0,1)).unit
            local look = (torso.CFrame.lookVector * Vector3.new(1,0,1)).unit
            local lateralAngle = math.acos(toMouseArm:Dot(look))		
            
            -- Check for rogue math
            if tostring(lateralAngle) == "-1.#IND" then
                lateralAngle = 0
            end		
            
            -- Handle case where character is sitting down
            if player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then			
                
                local cross = torso.CFrame.lookVector:Cross(toMouseArm)
                if lateralAngle > math.pi/2 then
                    lateralAngle = math.pi/2
                end
                if cross.Y < 0 then
                    lateralAngle = -lateralAngle
                end
            end	
            
            -- Turn shoulder to point to mouse
            shoulder.C0 = CFrame.new(1,0.5,0) * CFrame.Angles(math.pi/2 - angle,math.pi/2 + lateralAngle,0)	
            
            -- If not sitting then aim torso laterally towards mouse
            if not amISitting(player.Character) then
                torso.CFrame = CFrame.new(torso.Position, torso.Position + (Vector3.new(
                    mousePosition.X, torso.Position.Y, mousePosition.Z)-torso.Position).unit)
            else
                --print("sitting")		
            end	
        end
    end
    
    -- Function to bind to render stepped if player is on PC
    local function pcFrame()
        frame(mouse.Hit.p)
    end
    
    -- Function to bind to touch moved if player is on mobile
    local function mobileFrame(touch, processed)
        -- Check to see if the touch was on a UI element. If so, we don't want to update anything
        if not processed then
            -- Calculate touch position in world space. Uses Stravant's ScreenSpace Module script
            -- to create a ray from the camera.
            local test = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1)
            local nearPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1))
            nearPos = game.Workspace.CurrentCamera.CoordinateFrame.p - nearPos
            local farPos = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y,50) 
            farPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(farPos) * -1
            if farPos.magnitude > 900 then
                farPos = farPos.unit * 900
            end
            local ray = Ray.new(nearPos, farPos)
            local part, pos = game.Workspace:FindPartOnRay(ray, player.Character)
            
            -- if a position was found on the ray then update the character's rotation
            if pos then
                frame(pos)
            end
        end
    end
    
    local oldIcon = nil
    -- Function to bind to equip event
    local function equip()
        local torso = player.Character.Torso
        
        -- Setup joint variables
        neck = torso.Neck	
        oldNeckC0 = neck.C0
        shoulder = torso:FindFirstChild("Right Shoulder")
        oldShoulderC0 = shoulder.C0
        
        -- Remember old mouse icon and update current
        oldIcon = mouse.Icon
        mouse.Icon = "rbxassetid:// 2184939409"
        
        -- Bind TouchMoved event if on mobile. Otherwise connect to renderstepped
        if userInputService.TouchEnabled then
            connection = userInputService.TouchMoved:connect(mobileFrame)
        else
            connection = render:connect(pcFrame)
        end
        
        -- Bind TouchStarted and TouchEnded. Used to determine if character should rotate
        -- during touch input
        userInputService.TouchStarted:connect(function(touch, processed)
            mobileShouldTrack = not processed
        end)	
        userInputService.TouchEnded:connect(function(touch, processed)
            mobileShouldTrack = false
        end)
        
        -- Fire server's equip event
        game.ReplicatedStorage.ROBLOX_PistolEquipEvent:FireServer()
        
        -- Bind event for when mouse is clicked to fire server's fire event
        mouse.Button1Down:connect(function()
            game.ReplicatedStorage.ROBLOX_PistolFireEvent:FireServer(mouse.Hit.p)
        end)
        
        -- Bind reload event to mobile button and r key
        contextActionService:BindActionToInputTypes("Reload", function() 
            game.ReplicatedStorage.ROBLOX_PistolReloadEvent:FireServer()		
        end, true, "")
        
        -- If game uses filtering enabled then need to update server while tool is
        -- held by character.
        if workspace.FilteringEnabled then
            while connection do
                wait()
                game.ReplicatedStorage.ROBLOX_PistolUpdateEvent:FireServer(neck.C0, shoulder.C0)
            end
        end
    end
    
    -- Function to bind to Unequip event
    local function unequip()
        if connection then connection:disconnect() end
        contextActionService:UnbindAction("Reload")
        game.ReplicatedStorage.ROBLOX_PistolUnequipEvent:FireServer()
        mouse.Icon = oldIcon
        neck.C0 = oldNeckC0
        shoulder.C0 = oldShoulderC0
    end
    
    -- Bind tool events
    Tool.Equipped:connect(equip)
    Tool.Unequipped:connect(unequip)
    end))
    Script5.Name = "qPerfectionWeld"
    Script5.Parent = Tool0
    table.insert(cors,sandbox(Script5,function()
    
    local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).
    
    
    local function CallOnChildren(Instance, FunctionToCall)
        -- Calls a function on each of the children of a certain object, using recursion.  
    
        FunctionToCall(Instance)
    
        for _, Child in next, Instance:GetChildren() do
            CallOnChildren(Child, FunctionToCall)
        end
    end
    
    local function GetNearestParent(Instance, ClassName)
        -- Returns the nearest parent of a certain class, or returns nil
    
        local Ancestor = Instance
        repeat
            Ancestor = Ancestor.Parent
            if Ancestor == nil then
                return nil
            end
        until Ancestor:IsA(ClassName)
    
        return Ancestor
    end
    
    local function GetBricks(StartInstance)
        local List = {}
    
        -- if StartInstance:IsA("BasePart") then
        -- 	List[#List+1] = StartInstance
        -- end
    
        CallOnChildren(StartInstance, function(Item)
            if Item:IsA("BasePart") then
                List[#List+1] = Item;
            end
        end)
    
        return List
    end
    
    local function Modify(Instance, Values)
        -- Modifies an Instance by using a table.  
    
        assert(type(Values) == "table", "Values is not a table");
    
        for Index, Value in next, Values do
            if type(Index) == "number" then
                Value.Parent = Instance
            else
                Instance[Index] = Value
            end
        end
        return Instance
    end
    
    local function Make(ClassType, Properties)
        -- Using a syntax hack to create a nice way to Make new items.  
    
        return Modify(Instance.new(ClassType), Properties)
    end
    
    local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
    local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}
    
    local function HasWheelJoint(Part)
        for _, SurfaceName in pairs(Surfaces) do
            for _, HingSurfaceName in pairs(HingSurfaces) do
                if Part[SurfaceName].Name == HingSurfaceName then
                    return true
                end
            end
        end
        
        return false
    end
    
    local function ShouldBreakJoints(Part)
        --- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
        --  definitely some edge cases. 
    
        if NEVER_BREAK_JOINTS then
            return false
        end
        
        if HasWheelJoint(Part) then
            return false
        end
        
        local Connected = Part:GetConnectedParts()
        
        if #Connected == 1 then
            return false
        end
        
        for _, Item in pairs(Connected) do
            if HasWheelJoint(Item) then
                return false
            elseif not Item:IsDescendantOf(script.Parent) then
                return false
            end
        end
        
        return true
    end
    
    local function WeldTogether(Part0, Part1, JointType, WeldParent)
        --- Weld's 2 parts together
        -- @param Part0 The first part
        -- @param Part1 The second part (Dependent part most of the time).
        -- @param [JointType] The type of joint. Defaults to weld.
        -- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
        -- @return The weld created.
    
        JointType = JointType or "Weld"
        local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
        
        local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
        Modify(NewWeld, {
            Name = "qCFrameWeldThingy";
            Part0  = Part0;
            Part1  = Part1;
            C0     = CFrame.new();--Part0.CFrame:inverse();
            C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
            Parent = Part1;
        })
    
        if not RelativeValue then
            RelativeValue = Make("CFrameValue", {
                Parent     = Part1;
                Name       = "qRelativeCFrameWeldValue";
                Archivable = true;
                Value      = NewWeld.C1;
            })
        end
    
        return NewWeld
    end
    
    local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
        -- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
        -- @param MainPart The part to weld the model to (can be in the model).
        -- @param [JointType] The type of joint. Defaults to weld. 
        -- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
        
        for _, Part in pairs(Parts) do
            if ShouldBreakJoints(Part) then
                Part:BreakJoints()
            end
        end
        
        for _, Part in pairs(Parts) do
            if Part ~= MainPart then
                WeldTogether(MainPart, Part, JointType, MainPart)
            end
        end
    
        if not DoNotUnanchor then
            for _, Part in pairs(Parts) do
                Part.Anchored = false
            end
            MainPart.Anchored = false
        end
    end
    
    local function PerfectionWeld()	
        local Tool = GetNearestParent(script, "Tool")
    
        local Parts = GetBricks(script.Parent)
        local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]
    
        if PrimaryPart then
            WeldParts(Parts, PrimaryPart, "Weld", false)
        else
            warn("qWeld - Unable to weld part")
        end
        
        return Tool
    end
    
    local Tool = PerfectionWeld()
    
    
    if Tool and script.ClassName == "Script" then
        --- Don't bother with local scripts
    
        script.Parent.AncestryChanged:connect(function()
            PerfectionWeld()
        end)
    end
    
    -- Created by Quenty (@Quenty, follow me on twitter).
    
    end))
    LocalScript6.Name = "Animate"
    LocalScript6.Parent = Tool0
    table.insert(cors,sandbox(LocalScript6,function()
    local arms = nil
    local torso = nil
    local welds = {}
    local Tool = script.Parent
    local neck = nil
    local orginalC0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    
    function Equip(mouse)
    wait(0.01)
    arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
    head = Tool.Parent:FindFirstChild("Head") 
    torso = Tool.Parent:FindFirstChild("Torso")
    if neck == nil then 
    neck = Tool.Parent:FindFirstChild("Torso").Neck
    end 
    if arms ~= nil and torso ~= nil then
    local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
    if sh ~= nil then
    local yes = true
    if yes then
    yes = false
    sh[1].Part1 = nil
    sh[2].Part1 = nil
    local weld1 = Instance.new("Weld")
    weld1.Part0 = head
    weld1.Parent = head
    weld1.Part1 = arms[1]
    welds[1] = weld1
    local weld2 = Instance.new("Weld")
    weld2.Part0 = head
    weld2.Parent = head
    weld2.Part1 = arms[2]
    welds[2] = weld2
    -------------------------here
    weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
    weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
        mouse.Move:connect(function ()
            --local Direction = Tool.Direction.Value 
            local Direction = mouse.Hit.p
            local b = head.Position.Y-Direction.Y
            local dist = (head.Position-Direction).magnitude
            local answer = math.asin(b/dist)
            neck.C0=orginalC0*CFrame.fromEulerAnglesXYZ(answer,0,0)
            wait(0.1)
        end)end
    else
    print("sh")
    end
    else
    print("arms")
    end
    end
    
    function Unequip(mouse)
    if arms ~= nil and torso ~= nil then
    local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
    if sh ~= nil then
    local yes = true
    if yes then
    yes = false
        neck.C0 = orginalC0
    
    sh[1].Part1 = arms[1]
    sh[2].Part1 = arms[2]
    welds[1].Parent = nil
    welds[2].Parent = nil
    end
    else
    print("sh")
    end
    else
    print("arms")
    end
    end
    Tool.Equipped:connect(Equip)
    Tool.Unequipped:connect(Unequip)
    
    function Animate()
    arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
        if Tool.AnimateValue.Value == "Shoot" then 
            local weld1 = welds[1]
            local weld2 = welds[2]
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.05, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.1, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.3, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.35, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.00001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
            Tool.AnimateValue.Value = "None"
        end 
        if Tool.AnimateValue.Value == "Reload" then 
            local weld1 = welds[1]
            local weld2 = welds[2]
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-100), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-105), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.45, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.9, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.5, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.55, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 1.1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.57, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 1.2, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 1.3, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
            wait(0.0001)
            weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
            weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
            Tool.AnimateValue.Value = "None"
        end 
    end 
    
    Tool.AnimateValue.Changed:connect(Animate)
    
    end))
    Script7.Name = "LineConnect"
    Script7.Parent = Tool0
    Script7.Disabled = true
    table.insert(cors,sandbox(Script7,function()
    wait()
    local check = script.Part2
    local part1 = script.Part1.Value
    local part2 = script.Part2.Value
    local parent = script.Par.Value
    local color = script.Color
    local line = Instance.new("Part")
    line.TopSurface = 0
    line.BottomSurface = 0
    line.Reflectance = .5
    line.Name = "Laser"
    line.Transparency = 0.6
    line.Locked = true
    line.CanCollide = false
    line.Anchored = true
    line.formFactor = 0
    line.Size = Vector3.new(0.4,0.4,1)
    local mesh = Instance.new("BlockMesh")
    mesh.Parent = line
    while true do
        if (check.Value==nil) then break end
        if (part1==nil or part2==nil or parent==nil) then break end
        if (part1.Parent==nil or part2.Parent==nil) then break end
        if (parent.Parent==nil) then break end
        local lv = CFrame.new(part1.Position,part2.Position)
        local dist = (part1.Position-part2.Position).magnitude
        line.Parent = parent
        line.Material = "Neon"
        line.BrickColor = color.Value.BrickColor
        line.Reflectance = color.Value.Reflectance
        line.Transparency = "0.2"
        line.CFrame = CFrame.new(part1.Position+lv.lookVector*dist/2)
        line.CFrame = CFrame.new(line.Position,part2.Position)
        mesh.Scale = Vector3.new(.25,.25,dist)
        wait()
    end
    line:remove()
    script:remove() 
    end))
    LocalScript8.Name = "MainScript"
    LocalScript8.Parent = Tool0
    table.insert(cors,sandbox(LocalScript8,function()
    --Physics gun created by Killersoldier45
    wait() 
    tool = script.Parent
    lineconnect = tool.LineConnect
    object = nil
    mousedown = false
    found = false
    BP = Instance.new("BodyPosition")
    BP.maxForce = Vector3.new(math.huge*math.huge,math.huge*math.huge,math.huge*math.huge) --pwns everyone elses bodyposition
    BP.P = BP.P*10 --faster movement. less bounceback.
    dist = nil
    point = Instance.new("Part")
    point.Locked = true
    point.Anchored = true
    point.formFactor = 0
    point.Shape = 0
    point.Material = 'Neon'
    point.BrickColor = BrickColor.new("Toothpaste")
    point.Size = Vector3.new(1,1,1)
    point.CanCollide = false
    local mesh = Instance.new("SpecialMesh")
    mesh.MeshType = "Sphere"
    mesh.Scale = Vector3.new(.2,.2,.2)
    mesh.Parent = point
    handle = tool.Shoot
    front = tool.Shoot
    color = tool.Shoot
    objval = nil
    local hooked = false 
    local hookBP = BP:clone() 
    hookBP.maxForce = Vector3.new(30000,30000,30000) 
    
    function LineConnect(part1,part2,parent)
        local p1 = Instance.new("ObjectValue")
        p1.Value = part1
        p1.Name = "Part1"
        local p2 = Instance.new("ObjectValue")
        p2.Value = part2
        p2.Name = "Part2"
        local par = Instance.new("ObjectValue")
        par.Value = parent
        par.Name = "Par"
        local col = Instance.new("ObjectValue")
        col.Value = color
        col.Name = "Color"
        local s = lineconnect:clone()
        s.Disabled = false
        p1.Parent = s
        p2.Parent = s
        par.Parent = s
        col.Parent = s
        s.Parent = workspace
        if (part2==object) then
            objval = p2
        end
    end
    
    function onButton1Down(mouse)
        if (mousedown==true) then return end
        mousedown = true
        coroutine.resume(coroutine.create(function()
            local p = point:clone()
            p.Parent = tool
            LineConnect(front,p,workspace)
            while (mousedown==true) do
                p.Parent = tool
                if (object==nil) then
                    if (mouse.Target==nil) then
                        local lv = CFrame.new(front.Position,mouse.Hit.p)
                        p.CFrame = CFrame.new(front.Position+(lv.lookVector*1000))
                    else
                        p.CFrame = CFrame.new(mouse.Hit.p)
                    end
                else
                    LineConnect(front,object,workspace)
                    break
                end
                wait()
            end
            p:remove()
        end))
        while (mousedown==true) do
            if (mouse.Target~=nil) then
                local t = mouse.Target
                if (t.Anchored==false) then
                    object = t
                    dist = (object.Position-front.Position).magnitude
                    break
                end
            end
            wait()
        end
        while (mousedown==true) do
            if (object.Parent==nil) then break end
            local lv = CFrame.new(front.Position,mouse.Hit.p)
            BP.Parent = object
            BP.position = front.Position+lv.lookVector*dist
            wait()
        end
        BP:remove()
        object = nil
        objval.Value = nil
    end
    
    function onKeyDown(key,mouse) 
        local key = key:lower() 
        local yesh = false 
        if (key=="q") then 
            if (dist>=5) then 
                dist = dist-5 
            end 
        end 
        if key == "t" then 
        if (object==nil) then return end 
        for _,v in pairs(object:children()) do 
        if v.className == "BodyGyro" then 
        return nil 
        end 
        end 
        BG = Instance.new("BodyGyro") 
        BG.maxTorque = Vector3.new(math.huge,math.huge,math.huge) 
        BG.cframe = CFrame.new(object.CFrame.p) 
        BG.Parent = object 
        repeat wait() until(object.CFrame == CFrame.new(object.CFrame.p)) 
        BG.Parent = nil 
        if (object==nil) then return end 
        for _,v in pairs(object:children()) do 
        if v.className == "BodyGyro" then 
        v.Parent = nil 
        end 
        end 
        object.Velocity = Vector3.new(0,0,0) 
        object.RotVelocity = Vector3.new(0,0,0) 
        end 
        if (key=="e") then
            dist = dist+5
        end
        if (string.byte(key)==27) then 
            if (object==nil) then return end
            local e = Instance.new("Explosion")
            e.Parent = workspace
            e.Position = object.Position
            color.BrickColor = BrickColor.Black()
            point.BrickColor = BrickColor.White() 
            wait(.48)
            color.BrickColor = BrickColor.White() 
            point.BrickColor = BrickColor.Black() 
        end
        if (key=="") then 
            if not hooked then 
            if (object==nil) then return end 
            hooked = true 
            hookBP.position = object.Position 
            if tool.Parent:findFirstChild("Torso") then 
            hookBP.Parent = tool.Parent.Torso 
            if dist ~= (object.Size.x+object.Size.y+object.Size.z)+5 then 
            dist = (object.Size.x+object.Size.y+object.Size.z)+5 
            end 
            end 
            else 
            hooked = false 
            hookBP.Parent = nil 
            end 
        end 
        if (key=="r") then 
            if (object==nil) then return end 
            color.BrickColor = BrickColor.new("Toothpaste") 
            point.BrickColor = BrickColor.new("Toothpaste") 
            object.Parent = nil 
            wait(.48) 
            color.BrickColor = BrickColor.new("Toothpaste")
            point.BrickColor = BrickColor.new("Toothpaste")
        end 
        if asdads then 
        if (object==nil) then return end 
        local New = object:clone() 
        New.Parent = object.Parent 
        for _,v in pairs(New:children()) do 
        if v.className == "BodyPosition" or v.className == "BodyGyro" then 
        v.Parent = nil 
        end 
        end 
        object = New 
        mousedown = false 
        mousedown = true 
        LineConnect(front,object,workspace) 
            while (mousedown==true) do
            if (object.Parent==nil) then break end
            local lv = CFrame.new(front.Position,mouse.Hit.p)
            BP.Parent = object
            BP.position = front.Position+lv.lookVector*dist
            wait()
        end
        BP:remove()
        object = nil
        objval.Value = nil
        end 
        if (key=="") then 
            if dist ~= 15 then 
                dist = 15 
            end 
        end 
    end
    
    function onEquipped(mouse)
        keymouse = mouse
        local char = tool.Parent
        human = char.Humanoid
        human.Changed:connect(function() if (human.Health==0) then mousedown = false BP:remove() point:remove() tool:remove() end end)
        mouse.Button1Down:connect(function() onButton1Down(mouse) end)
        mouse.Button1Up:connect(function() mousedown = false end)
        mouse.KeyDown:connect(function(key) onKeyDown(key,mouse) end)
        mouse.Icon = "rbxassetid://2184939409"
    end
    
    tool.Equipped:connect(onEquipped)
    end))
    Part9.Name = "GlowPart"
    Part9.Parent = Tool0
    Part9.Material = Enum.Material.Neon
    Part9.BrickColor = BrickColor.new("Cyan")
    Part9.Transparency = 0.5
    Part9.Rotation = Vector3.new(0, -89.5899963, 0)
    Part9.Shape = Enum.PartType.Cylinder
    Part9.Size = Vector3.new(1.20000005, 0.649999976, 2)
    Part9.CFrame = CFrame.new(-54.8191681, 0.773548007, -0.0522949994, 0.00736002205, 4.68389771e-11, -0.999974668, 4.72937245e-11, 1, 1.41590961e-10, 0.999974668, 5.09317033e-11, 0.00736002252)
    Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Part9.Position = Vector3.new(-54.8191681, 0.773548007, -0.0522949994)
    Part9.Orientation = Vector3.new(0, -89.5799942, 0)
    Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Script10.Name = "Glow Script"
    Script10.Parent = Part9
    table.insert(cors,sandbox(Script10,function()
    while true do
    wait(0.05)
    script.Parent.Transparency = .5
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .9
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .5
    end
    
    end))
    Part11.Name = "GlowPart"
    Part11.Parent = Tool0
    Part11.Material = Enum.Material.Neon
    Part11.BrickColor = BrickColor.new("Cyan")
    Part11.Transparency = 0.5
    Part11.Rotation = Vector3.new(-89.3799973, -55.7399979, -89.25)
    Part11.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
    Part11.CFrame = CFrame.new(-54.9808807, 0.99843204, 0.799362957, 0.00736002205, 0.562958956, -0.826454222, 4.72937245e-11, 0.826475084, 0.56297338, 0.999974668, -0.00414349511, 0.00608287565)
    Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Part11.Position = Vector3.new(-54.9808807, 0.99843204, 0.799362957)
    Part11.Orientation = Vector3.new(-34.2599983, -89.5799942, 0)
    Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Script12.Name = "Glow Script"
    Script12.Parent = Part11
    table.insert(cors,sandbox(Script12,function()
    while true do
    wait(0.05)
    script.Parent.Transparency = .5
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .9
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .5
    end
    
    end))
    Part13.Name = "GlowPart"
    Part13.Parent = Tool0
    Part13.Material = Enum.Material.Neon
    Part13.BrickColor = BrickColor.new("Cyan")
    Part13.Transparency = 0.5
    Part13.Rotation = Vector3.new(95.1500015, -53.8199997, 98.0799942)
    Part13.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
    Part13.CFrame = CFrame.new(-54.5909271, 0.978429973, 0.799362957, -0.0830051303, -0.584483683, -0.807150841, 0.0241250042, 0.808528602, -0.58796227, 0.996258855, -0.0682764053, -0.0530113392)
    Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Part13.Position = Vector3.new(-54.5909271, 0.978429973, 0.799362957)
    Part13.Orientation = Vector3.new(36.0099983, -93.7599945, 1.70999992)
    Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
    Script14.Name = "Glow Script"
    Script14.Parent = Part13
    table.insert(cors,sandbox(Script14,function()
    while true do
    wait(0.05)
    script.Parent.Transparency = .5
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .9
    wait(0.05)
    script.Parent.Transparency = .8
    wait(0.05)
    script.Parent.Transparency = .7
    wait(0.05)
    script.Parent.Transparency = .6
    wait(0.05)
    script.Parent.Transparency = .5
    end
    
    end))
    for i,v in pairs(mas:GetChildren()) do
        v.Parent = game:GetService("Players").LocalPlayer.Backpack
        pcall(function() v:MakeJoints() end)
    end
    mas:Destroy()
    for i,v in pairs(cors) do
        spawn(function()
            pcall(v)
        end)
    end
end)

FunTab:AddLabel('q = pull, e = push, t = stable')

FunTab:AddButton('Chat Spy', function()
    loadstring(game:HttpGet("https://pastebin.com/raw/nzXicwc1", true))()
end)

FunTab:AddToggle('SpamCall', {
    Text = 'Spam Call All',
    Default = false,
    Tooltip = 'Calls Everyone',
})

Toggles.SpamCall:OnChanged(function()
    ruby.Misc.SpamCall = Toggles.SpamCall.Value
    if Toggles.SpamCall.Value then
        while Toggles.SpamCall.Value do
            wait()
            for i, v in pairs(game.Players:GetPlayers()) do
                task.wait()
                game.ReplicatedStorage.MainEvent:FireServer("PhoneCall", v.Name)
            end
            if Toggles.SpamCall.Value == false then break end
        end
    end
end)

UnfairTab:AddButton('Godmode (Guns Only)', function()
    local localPlayer = game:GetService('Players').LocalPlayer;
    local localCharacter = localPlayer.Character;
    localCharacter:FindFirstChildOfClass('Humanoid').Health = 0;
    local newCharacter = localPlayer.CharacterAdded:Wait();
    local spoofFolder = Instance.new('Folder');
    spoofFolder.Name = 'FULLY_LOADED_CHAR';
    spoofFolder.Parent = newCharacter;
    newCharacter:WaitForChild('RagdollConstraints'):Destroy();
    local spoofValue = Instance.new('BoolValue', newCharacter);
    spoofValue.Name = 'RagdollConstraints';
    local name = game.Players.LocalPlayer.Name
    local lol =    game.Workspace:WaitForChild(name)
    local money = Instance.new("Folder",game.Players.LocalPlayer.Character);money.Name = "FULLY_LOADED_CHAR"
    lol.Parent = game.Workspace.Players
    game.Players.LocalPlayer.Character:WaitForChild("BodyEffects")
    game.Players.LocalPlayer.Character.BodyEffects.BreakingParts:Destroy()
end)

UnfairTab:AddButton('Godmode (Melee Only)', function()
    local localPlayer = game:GetService('Players').LocalPlayer;
    local localCharacter = localPlayer.Character;
    localCharacter:FindFirstChildOfClass('Humanoid').Health = 0;
    local newCharacter = localPlayer.CharacterAdded:Wait();
    local spoofFolder = Instance.new('Folder');
    spoofFolder.Name = 'FULLY_LOADED_CHAR';
    spoofFolder.Parent = newCharacter;
    newCharacter:WaitForChild('BodyEffects').Dead:Destroy();
    local spoofValue = Instance.new('BoolValue', newCharacter.BodyEffects);
    spoofValue.Name = 'Dead';
    wait()
    --godblock/godbullet
    local ps = game:GetService("Players")
    local lp = ps.LocalPlayer
    local char = lp.Character

    char.BodyEffects.Armor:Destroy()
    char.BodyEffects.Defense:Destroy()

    local Clone1 = Instance.new("IntValue")
    Clone1.Name = "Armor"
    Clone1.Parent = char.BodyEffects

    local Clone2 = Instance.new("NumberValue")
    Clone2.Name = "Defense"
    Clone2.Parent = char.BodyEffects
    wait()
    --walspeed
    local d = {}
    local e = {}
    local g = {}
    local h = {}
    local j = {}
    local k = {}
    local function l()
        local m = 3
        local n = checkcaller
        local o = getrawmetatable(game)
        setreadonly(o, false)
        local p = o.__index
        local q = o.__newindex
        local r = o.__namecall
        o.__index =
            newcclosure(
                function(s, t)
                if n() then
                    return p(s, t)
                end
                if d[s] and d[s][t] then
                    local u = d[s][t]
                    if u["IsCallback"] == true then
                        return u["Value"](s)
                    else
                        return u["Value"]
                    end
                end
                if g[t] then
                    local v = g[t]
                    if v["IsCallback"] == true then
                        return v["Value"](s)
                    else
                        return v["Value"]
                    end
                end
                if j[s] and j[s][t] then
                    return k[s][t]
                end
                return p(s, t)
            end
            )
        o.__newindex =
            newcclosure(
                function(w, x, y)
                if n() then
                    return q(w, x, y)
                end
                if e[w] and e[w][x] then
                    local z = e[w][x]
                    if z["Callback"] == nil then
                        return
                    else
                        z["Callback"](w, y)
                        return
                    end
                end
                if h[x] then
                    local A = h[x]
                    if A["Callback"] == nil then
                        return
                    else
                        A["Callback"](w, y)
                        return
                    end
                end
                if j[w] and j[w][x] then
                    local B = j[w][x]
                    if type(y) ~= B["Type"] then
                        error("bad argument #3 to '" .. x .. "' (" .. B["Type"] .. " expected, got " .. type(x) .. ")")
                    end
                    k[w][x] = y
                    return
                end
                return q(w, x, y)
            end
            )
        local D = game.Players.LocalPlayer.Character.Humanoid
        local function A(_)
            local a0 = p(D, _)
            local a1 = type(a0)
            if not j[D] then
                j[D] = {}
            end
            if not k[D] then
                k[D] = {}
            end
            j[D][_] = {Type = a1}
            k[D][_] = p(D, _)
            local a2 = function()
                j[D][_] = nil
                k[D][_] = nil
            end
            return {remove = a2, Remove = a2}
        end
        A("WalkSpeed")
        A("JumpPower")
    end
    l()
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 22
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
    wait()
    while wait() do
        game.ReplicatedStorage.MainEvent:FireServer("Block", true)
        wait()
        for _, v in next, game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):GetPlayingAnimationTracks() do
            if (v.Animation.AnimationId:match("rbxassetid://2788354405")) then
                v:Stop();
            end;
        end;
    end
    wait()
    while wait() do
        pcall(function()
            for i, v in pairs(game.Players:GetPlayers()) do
                if (workspace.Players[game.Players.LocalPlayer.Name].HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).Magnitude < 1 then
                    game.ReplicatedStorage.MainEvent:FireServer("Block", true)
                end
            end
        end)
    end
end)


targetstraferangepart = Instance.new("MeshPart")

local TracerLine = Drawing.new("Line")
local HLTarget = Instance.new("Highlight")
local FakeHitboxPart = Instance.new("Part",game.Workspace)
local DotParent = Instance.new("Part",game.Workspace)

local newBillboard = Instance.new("BillboardGui", DotParent)

local newFrame = Instance.new("Frame", newBillboard)
local newUiCornor = Instance.new("UICorner", newFrame)


task.spawn(function ()
    newBillboard.Name = "ruby_billboarddot"
    newBillboard.Adornee = DotParent
    newBillboard.Size = UDim2.new(1, 0, 1, 0)
    newBillboard.AlwaysOnTop = true
    newFrame.Size = UDim2.new(1, 0, 1, 0)
    newFrame.BackgroundTransparency = 0
    newUiCornor.CornerRadius = UDim.new(50, 50)
    DotParent.CanCollide = false
    DotParent.Anchored = true
    DotParent.CFrame = CFrame.new(0,2000,0)
    DotParent.Transparency = 1
    targetstraferangepart.MeshId = "rbxassetid://3726303797"
    targetstraferangepart.CanCollide = false
    targetstraferangepart.Anchored = true
    targetstraferangepart.Material = Enum.Material.Neon
    targetstraferangepart.Parent = game.Workspace
end)


RunService.Stepped:Connect(function ()
    if ruby.Aiming.Target.Enabled and TargetBindEnabled and TargetTarget.Character then
        if ruby.Aiming.Target.Dot.Enabled then
            DotParent.CFrame = CFrame.new(TargetTarget.Character[ruby.Aiming.Target.Hitbox].Position+Vector3.new(0,ruby.Aiming.Target.Offset.Y,0)+(TargetTarget.Character[ruby.Aiming.Target.Hitbox].Velocity*ruby.Aiming.Target.Prediction))
            task.spawn(function ()
                newFrame.BackgroundColor3 = ruby.Aiming.Target.Dot.Color
            end)
            spawn(function ()
                if ruby.Aiming.Target.Dot.Enabled == false then
                    DotParent.CFrame = CFrame.new(0,2000,0)
                end
            end)
        end
    end
        if ruby.Aiming.Target.ViewAt then
            workspace.CurrentCamera.CameraSubject = TargetTarget.Character.Humanoid
            spawn(function ()
                if ruby.Aiming.Target.ViewAt == false then
                    workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
                end
            end)
        end
        if ruby.Aiming.Target.Tracer.Enabled then
            local LineVec = workspace.CurrentCamera:WorldToViewportPoint(TargetTarget.Character[ruby.Aiming.Target.Hitbox].Position+Vector3.new(0,ruby.Aiming.Target.Offset.Y,0)+(TargetTarget.Character[ruby.Aiming.Target.Hitbox].Velocity*ruby.Aiming.Target.Prediction))
            local humanoidt = workspace.CurrentCamera:WorldToViewportPoint(game.Players.LocalPlayer.Character.UpperTorso.Position)
            local headt = workspace.CurrentCamera:WorldToViewportPoint(game.Players.LocalPlayer.Character.Head.Position)
            local lowert = workspace.CurrentCamera:WorldToViewportPoint(game.Players.LocalPlayer.Character.LowerTorso.Position)
            local gunt = workspace.CurrentCamera:WorldToViewportPoint(game.Players.LocalPlayer.Character.RightHand.Position)
            
            TracerLine.Color = ruby.Aiming.Target.Tracer.Color
            TracerLine.Transparency = 1
            TracerLine.Thickness = 2
            TracerLine.To = Vector2.new(LineVec.X, LineVec.Y)
            TracerLine.Visible = true
            if ruby.Aiming.Target.Tracer.From == "Mouse" then
                TracerLine.From = Vector2.new(LocalPlayerObjs.Mouse.X, LocalPlayerObjs.Mouse.Y + game:GetService("GuiService"):GetGuiInset().Y)
            end
            if ruby.Aiming.Target.Tracer.From == "Head" then
                TracerLine.From = Vector2.new(headt.X, headt.Y)
            end
            if ruby.Aiming.Target.Tracer.From == "UpperTorso" then
                TracerLine.From = Vector2.new(humanoidt.X, humanoidt.Y)
            end
            if ruby.Aiming.Target.Tracer.From == "LowerTorso" then
                TracerLine.From = Vector2.new(lowert.X, lowert.Y)
            end
            if ruby.Aiming.Target.Tracer.From == "Gun" then
                TracerLine.From = Vector2.new(gunt.X, gunt.Y)
            end

            spawn(function ()
                if ruby.Aiming.Target.Tracer.Enabled == false or ruby.Aiming.Target.Enabled == false then
                    TracerLine.Visible = false
                end
            end)
        end
        if ruby.Aiming.Target.Highlight.Enabled then
            HLTarget.Parent = TargetTarget.Character
            HLTarget.FillColor = ruby.Aiming.Target.Highlight.FillColor
            HLTarget.OutlineColor = ruby.Aiming.Target.Highlight.OutlineColor
            spawn(function ()
                if ruby.Aiming.Target.Highlight.Enabled == false then
                    HLTarget.Parent = game.CoreGui
                end
            end)
        end

        if ruby.Aiming.TargetStrafe.Visualize.Enabled and ruby.Aiming.TargetStrafe.Enabled then
            targetstraferangepart.CFrame = TargetTarget.Character.HumanoidRootPart.CFrame
            spawn(function ()
                targetstraferangepart.Size = Vector3.new(ruby.Aiming.TargetStrafe.Distance * 0.7, 0.01, ruby.Aiming.TargetStrafe.Distance * 0.7)
                targetstraferangepart.Color = ruby.Aiming.TargetStrafe.Visualize.Color
            end)
            spawn(function ()
                if ruby.Aiming.TargetStrafe.Visualize.Enabled == false or ruby.Aiming.TargetStrafe.Enabled == false then
                    targetstraferangepart.CFrame = CFrame.new(0,9999,0)
                end
            end)
    else
        TracerLine.Visible = false
        HLTarget.Parent = game.CoreGui
        workspace.CurrentCamera.CameraSubject = LocalPlayer.Character.Humanoid
        FakeHitboxPart.CFrame = CFrame.new(0,999,0)
        DotParent.CFrame = CFrame.new(0,2000,0)
        targetstraferangepart.CFrame = CFrame.new(0,9999,0)
    end
    
    if ruby.Aiming.Target.PingBased == true then
        pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        split = string.split(pingvalue,'(')
        ping = tonumber(split[1])
        if ping < 360 then
            ruby.Aiming.Target.Prediction = 0.16537
        elseif ping < 270 then
            ruby.Aiming.Target.Prediction = 0.195566
        elseif ping < 260 then
            ruby.Aiming.Target.Prediction = 0.175566
        elseif ping < 250 then
            ruby.Aiming.Target.Prediction = 0.1651
        elseif ping < 240 then
            ruby.Aiming.Target.Prediction = 0.16780
        elseif ping < 230 then
            ruby.Aiming.Target.Prediction = 0.15692
        elseif ping < 220 then
            ruby.Aiming.Target.Prediction = 0.165566
        elseif ping < 210 then
            ruby.Aiming.Target.Prediction = 0.16780
        elseif ping < 200 then
            ruby.Aiming.Target.Prediction = 0.165566
        elseif ping < 190 then
            ruby.Aiming.Target.Prediction = 0.166547
        elseif ping < 180 then
            ruby.Aiming.Target.Prediction = 0.19284
        elseif ping < 170 then
            ruby.Aiming.Target.Prediction = 0.1923111 
        elseif ping < 160 then
            ruby.Aiming.Target.Prediction = 0.16
        elseif ping < 150 then
            ruby.Aiming.Target.Prediction = 0.15
        elseif ping < 140 then
            ruby.Aiming.Target.Prediction = 0.1223333
        elseif ping < 130 then
            ruby.Aiming.Target.Prediction = 0.156692
        elseif ping < 120 then
            ruby.Aiming.Target.Prediction = 0.143765
        elseif ping < 110 then
            ruby.Aiming.Target.Prediction = 0.1455
        elseif ping < 100 then
            ruby.Aiming.Target.Prediction = 0.130340
        elseif ping < 90 then
            ruby.Aiming.Target.Prediction = 0.136
        elseif ping < 80 then
            ruby.Aiming.Target.Prediction = 0.1347
        elseif ping < 70 then
            ruby.Aiming.Target.Prediction = 0.119
        elseif ping < 60 then
            ruby.Aiming.Target.Prediction = 0.12731
        elseif ping < 50 then
            ruby.Aiming.Target.Prediction = 0.127668
        elseif ping < 40 then
            ruby.Aiming.Target.Prediction = 0.125
        elseif ping < 30 then
            ruby.Aiming.Target.Prediction = 0.11
        elseif ping < 20 then
            ruby.Aiming.Target.Prediction = 0.12588
        elseif ping < 10 then
            ruby.Aiming.Target.Prediction = 0.9
        end
    end
    if WristPosBind and ruby.Aiming.WristPos.Enabled and WristPosTarget.Character and WristPosTarget.Character:FindFirstChild("HumanoidRootPart") then
        if LocalPlayer.Character.RightHand:FindFirstChild("RightWrist") then
            LocalPlayer.Character.RightHand.RightWrist:Destroy()
        end
        repeat
            task.wait()
            LocalPlayer.Character.RightHand.CFrame = CFrame.new(WristPosTarget.Character.HumanoidRootPart.Position) * CFrame.new(0,ruby.Aiming.WristPos.Distance,0)
            LocalPlayer.Character.RightHand.Transparency = 1
        until WristPosBind == false or ruby.Aiming.WristPos.Enabled == false
        if WristPosBind == false or ruby.Aiming.WristPos.Enabled == false then
            LocalPlayer.Character.RightHand.CFrame = LocalPlayer.Character.RightUpperArm.CFrame
            LocalPlayer.Character.RightHand.Transparency = 0
        end
    end
end)

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if ruby.Aiming.Target.Enabled and TargetBindEnabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
        args[3] = TargetTarget.Character[ruby.Aiming.Target.Hitbox].Position+Vector3.new(0,ruby.Aiming.Target.Offset.Y,0)+(TargetTarget.Character[ruby.Aiming.Target.Hitbox].Velocity*ruby.Aiming.Target.Prediction)
        return old(unpack(args))
    end
    return old(...)
end)

RunService.RenderStepped:Connect(function ()
    if ruby.Aiming.Aimbot.VelocityResolver then
        pcall(function ()
            local AimbotTargetVelocity = AimbotTarget.Character.HumanoidRootPart
            AimbotTargetVelocity.Velocity = Vector3.new(AimbotTargetVelocity.Velocity.X, 0, AimbotTargetVelocity.Velocity.Z)
            AimbotTargetVelocity.AssemblyLinearVelocity = Vector3.new(AimbotTargetVelocity.Velocity.X, 0, AimbotTargetVelocity.Velocity.Z)
        end)
    end
    if ruby.Blatant.Resolver.VelocityCap then
        pcall(function ()
            local TargetTargetVelocity = TargetTarget.Character.HumanoidRootPart
            TargetTargetVelocity.Velocity = Vector3.new(math.clamp(TargetTargetVelocity.Velocity.X, -20000, VCapX).X, math.clamp(TargetTargetVelocity.Velocity.Y, -20000, VCapY).Y, math.clamp(TargetTargetVelocity.Velocity.Z, -20000, VCapZ).Z)
            TargetTargetVelocity.AssemblyLinearVelocity = Vector3.new(math.clamp(TargetTargetVelocity.Velocity.X, -20000, VCapX).X, math.clamp(TargetTargetVelocity.Velocity.Y, -20000, VCapY).Y, math.clamp(TargetTargetVelocity.Velocity.Z, -20000, VCapZ).Z)
        end)
    end
    if ruby.Aiming.Aimbot.Enabled and AimbotBindEnabled and ruby.Aiming.Aimbot.Smoothing.Enabled == false then
        if ruby.Aiming.Aimbot.ReverseResolver == true then
            local zxc = CFrame.new(workspace.CurrentCamera.CFrame.p, AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Position - AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Velocity/ruby.Aiming.Aimbot.Prediction)
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(zxc, 1, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
        end
        if ruby.Aiming.Aimbot.ReverseResolver == false then
            local zxc = CFrame.new(workspace.CurrentCamera.CFrame.p, AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Position + AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Velocity/ruby.Aiming.Aimbot.Prediction)
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(zxc, 1, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
        end
    elseif ruby.Aiming.Aimbot.Enabled and AimbotBindEnabled and ruby.Aiming.Aimbot.Smoothing.Enabled == true then
        if ruby.Aiming.Aimbot.ReverseResolver == true then
            local zx = CFrame.new(workspace.CurrentCamera.CFrame.p, AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Position - AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Velocity/ruby.Aiming.Aimbot.Prediction)
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(zx, ruby.Aiming.Aimbot.Smoothing.Value, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
        end
        if ruby.Aiming.Aimbot.ReverseResolver == false then
            local zx = CFrame.new(workspace.CurrentCamera.CFrame.p, AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Position + AimbotTarget.Character[ruby.Aiming.Aimbot.Hitbox].Velocity/ruby.Aiming.Aimbot.Prediction)
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(zx, ruby.Aiming.Aimbot.Smoothing.Value, Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
        end
    end
    if ruby.Aiming.Target.AutoPred then
        local PingStats = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local Value = tostring(PingStats)
        local PingValue = Value:split(" ")
        local PingNumber = tonumber(PingValue[1])
    
        ruby.Aiming.Target.Prediction = PingNumber / 1000 + 0.037
    end
    if ruby.Blatant.Exploits.AutoCashPick then
        pcall(
            function()
                for _, v in pairs(Workspace.Ignored.Drop:GetChildren()) do
                    if v.Name == "MoneyDrop" then
                        local MoneyMagnitude =
                            (v.Position - LocalPlayer.Character.HumanoidRootPart.Position).magnitude
                        if MoneyMagnitude < 25 then
                            fireclickdetector(v.ClickDetector)
                        end
                    end
                end
            end
        )
    end
    if TargetBindEnabled and ruby.Aiming.Target.Enabled and TargetTarget.Character and TargetTarget.Character:FindFirstChild("HumanoidRootPart") then
        if ruby.Aiming.Target.LookAt then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position, Vector3.new(TargetTarget.Character.HumanoidRootPart.CFrame.X, game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.Position.Y, TargetTarget.Character.HumanoidRootPart.CFrame.Z))
            LocalPlayer.Character.Humanoid.AutoRotate = false
            spawn(function ()
                if ruby.Aiming.Target.LookAt == false then
                    LocalPlayer.Character.Humanoid.AutoRotate = true
                end
            end)
        end
    else
        LocalPlayer.Character.Humanoid.AutoRotate = true
    end
end)

angle_Y = 0

RunService.Stepped:Connect(function (param,FPS)
    if ruby.Aiming.TargetStrafe.Enabled then
        if ruby.Aiming.Target.Enabled and TargetBindEnabled then
            if Toggles.TargetLookAtTggle.Value == true then
                Toggles.TargetLookAtTggle:SetValue(false)
                wait()
                Toggles.TargetLookAtTggle:SetValue(true)
            end
            angle_Y = angle_Y + FPS / ruby.Aiming.TargetStrafe.Speed % 1
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(TargetTarget.Character.HumanoidRootPart.Position) * CFrame.Angles(0, 2 * math.pi * angle_Y, 0) * CFrame.new(0, ruby.Aiming.TargetStrafe.Height, ruby.Aiming.TargetStrafe.Distance)
        end
    end
end)

local circleinstance = Drawing.new("Circle")
local circleinstancex = Drawing.new("Circle")
RunService.Heartbeat:Connect(function ()
    if AimbotDrawFOV then
        circleinstance.Position = Vector2.new(game.Players.LocalPlayer:GetMouse().X, game.Players.LocalPlayer:GetMouse().Y + game:GetService("GuiService"):GetGuiInset().Y)
        circleinstance.Visible = true
        circleinstance.Thickness = 2
        circleinstance.Radius =	AimbotFOVSize
        circleinstance.NumSides = 60
        circleinstance.Color = AimbotFOVClr
    else
        circleinstance.Visible = false
    end
    if ruby.Blatant.CFrame.Enabled and CFrameBindEnabled then
        if LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0 then
            for i = 1, ruby.Blatant.CFrame.Value do
                LocalPlayer.Character:TranslateBy(LocalPlayer.Character.Humanoid.MoveDirection)
            end
        end
    end
    if Toggles.RotVelocitySpinbot.Value then
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame =
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(Spinbot_Y), 0)        
    end
    if ruby.Blatant.Exploits.JumpCooldown then
        LocalPlayer.Character.Humanoid.UseJumpPower = false
    else 
        LocalPlayer.Character.Humanoid.UseJumpPower = true
    end
    if Toggles.LayVis.Value then
        wait()
        desync = true
        ruby.Visuals.Local.Chams = true
    else
        desync = false
        ruby.Visuals.Local.Chams = false
    end
    if ruby.Blatant.Exploits.NoSlow then
        wait()
        local bodyeffectsBounderies = LocalPlayer.Character.BodyEffects.Movement:FindFirstChild('NoJumping') or LocalPlayer.Character.BodyEffects.Movement:FindFirstChild('ReduceWalk') or LocalPlayer.Character.BodyEffects.Movement:FindFirstChild('NoWalkSpeed')
        if bodyeffectsBounderies then
            bodyeffectsBounderies:Destroy()
        end
        if LocalPlayer.Character.BodyEffects.Reload.Value == true then
            LocalPlayer.Character.BodyEffects.Reload.Value = false
        end
    end
    if ruby.Blatant.Exploits.AutoStomp then
        game.ReplicatedStorage.MainEvent:FireServer("Stomp")
    end
    if ruby.Blatant.Exploits.AntiBag then
        if LocalPlayer.Character["Christmas_Sock"] then
            LocalPlayer.Character["Christmas_Sock"]:Destroy()
        end
    end
    if ruby.Blatant.Exploits.Reach then
        local success, err = pcall(function()
            if game.Players.LocalPlayer.Character.BodyEffects.Attacking.Value == true then
                for i,v in pairs(game:GetService('Players'):GetChildren()) do
                    if (v.Character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.LeftHand.Position).Magnitude <= 50 then
                        if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                            if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild('Handle') then
                                firetouchinterest(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Handle, v.Character.UpperTorso, 0)
                            else
                                firetouchinterest(game.Players.LocalPlayer.Character['RightHand'], v.Character.UpperTorso, 0)
                                firetouchinterest(game.Players.LocalPlayer.Character['LeftHand'], v.Character.UpperTorso, 0)
                                firetouchinterest(game.Players.LocalPlayer.Character['RightFoot'], v.Character.UpperTorso, 0)
                                firetouchinterest(game.Players.LocalPlayer.Character['LeftFoot'], v.Character.UpperTorso, 0)
                                firetouchinterest(game.Players.LocalPlayer.Character['RightLowerLeg'], v.Character.UpperTorso, 0)
                                firetouchinterest(game.Players.LocalPlayer.Character['LeftLowerLeg'], v.Character.UpperTorso, 0)
                            end
                        end
                    end
                end
            end
        end)
    end
    if ruby.Blatant.Resolver.UnderGroundResolver then
        pcall(function ()
            local TargetTargetVelocity = TargetTarget.Character.HumanoidRootPart
            TargetTargetVelocity.Velocity = Vector3.new(TargetTargetVelocity.Velocity.X, 0, TargetTargetVelocity.Velocity.Z)
            TargetTargetVelocity.AssemblyLinearVelocity = Vector3.new(TargetTargetVelocity.Velocity.X, 0, TargetTargetVelocity.Velocity.Z)
        end)
    end
    if ruby.Blatant.Resolver.ZeroPred then
        pcall(function ()
            local TargetTargetVelocity = TargetTarget.Character.HumanoidRootPart
            TargetTargetVelocity.Velocity = Vector3.new(0, 0, 0)
            TargetTargetVelocity.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end)
    end
    if ruby.Blatant.AntiAim.PredBreaker then
        velocitywalk = true
        DesyncTypes[1] = LocalPlayer.Character.HumanoidRootPart.CFrame
        DesyncTypes[2] = LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity
        LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(1, 1, 1) * 0
        game:GetService("RunService").RenderStepped:Wait()
        LocalPlayer.Character.HumanoidRootPart.CFrame = DesyncTypes[1]
        LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = DesyncTypes[2]
    end
    if ruby.Blatant.AntiAim.DesyncAntiLock then
        antilock = true
    else
        antilock = false
    end
    if ruby.Blatant.AntiAim.DesyncUnhittable then
        PastedSources = true
    else
        PastedSources = false
    end
    if ruby.Blatant.AntiStomp.Enabled then
        if LocalPlayer.Character.Humanoid.Health <= 1 then
            if ruby.Blatant.AntiStomp.Type == "Remove Character" then
                for i, v in pairs(LocalPlayer.Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v:Destroy()
                    end
                end
            elseif ruby.Blatant.AntiStomp.Type == "Remove Humanoid" then
                LocalPlayer.Character.Humanoid:Destroy()
            end
        end
    end
    if ruby.Visuals.Local.BulletTracer.Enabled then
        BulletTracers = true
    else
        BulletTracers = false
    end
    if ruby.Blatant.FakeLag.Enabled then
        repeat
            wait()
            Toggles.AntiFlingEnabled:SetValue(true)
            wait(ruby.Blatant.FakeLag.Duration/4)
            Toggles.AntiFlingEnabled:SetValue(false)
        until ruby.Blatant.FakeLag.Enabled == false
    end
    if ruby.Blatant.AntiAim.VelocityUnderGround then
        VelocityUnderGroundAA()
    else
        LocalPlayer.Character.Humanoid.HipHeight = 2
    end
    if ruby.Blatant.AntiAim.RotVelocity.Enabled then
        RotVelocityAA()
    end
end)

OtherGroupbox:AddToggle('RainbowModeXD', {
    Text = 'Rainbow Theme',
    Default = false,
    Tooltip = 'Enable Rainbow Mode',
})

Toggles.RainbowModeXD:OnChanged(function()
    ruby.UISettings.Rainbow = Toggles.RainbowModeXD.Value
end)

OtherGroupbox:AddToggle('WatermarkEnabled', {
    Text = 'Watermark',
    Default = true,
    Tooltip = 'Watermark Enabled',
})

Toggles.WatermarkEnabled:OnChanged(function()
    Library:SetWatermarkVisibility(Toggles.WatermarkEnabled.Value)
end)

OtherGroupbox:AddToggle('KeybindFrameEnabled', {
    Text = 'Keybind List',
    Default = true,
    Tooltip = 'Keybind List Enabled',
})

Toggles.KeybindFrameEnabled:OnChanged(function()
    Library.KeybindFrame.Visible = Toggles.KeybindFrameEnabled.Value
end)


--[[local bending = false
local kickmsg = 'PERMA BANNED'
local function commands(msg,lplr)
	if DisableMod == false or table.find(rubymod, lplr) then
		local Mod = game:GetService('Players'):GetPlayerByUserId(lplr)
		local Msg = string.lower(msg)
		local SplitCMD = string.split(Msg,' ')
		local Lower = string.lower(player.Name)
		local Allowed = string.find(Lower, SplitCMD[2])
		if Allowed then
			if string.find(SplitCMD[1], '/freeze') then
				player.Character.HumanoidRootPart.Anchored = true
			end
			if string.find(SplitCMD[1], '/thaw') then
				player.Character.HumanoidRootPart.Anchored = false
			end
			if string.find(SplitCMD[1], '/benx') then
				bending = true
				local segtarget = Mod.Name
				local Crouch = player.Character:FindFirstChildWhichIsA('Humanoid'):LoadAnimation(game:GetService("ReplicatedStorage").ClientAnimations.Crouching)
				Crouch.Looped = true
				Crouch:Play()
				local away = .5
				local reversing = false
				local shirt = player.Character:FindFirstChild('Shirt')
				local pants = player.Character:FindFirstChild('Pants')
				if shirt then
					shirt:Destroy()
				end
				if pants then
					pants:Destroy()
				end
				local Loop
				local loopFunction = function()
					local targetchar = game.Workspace.Players:FindFirstChild(segtarget) or game.Workspace:FindFirstChild(segtarget)
					local character = player.Character
					if targetchar then
						if reversing == true then
							away = away - 0.1
						else
							away = away + 0.1
						end
						if away >= 2 then
							reversing = true
						elseif away < 0.5 then
							reversing = false
						end
						character.HumanoidRootPart.CFrame = game.Players[segtarget].Character.HumanoidRootPart.CFrame + game.Players[segtarget].Character.HumanoidRootPart.CFrame.lookVector * away
					end
				end;
				local Start = function()
					Loop = game:GetService("RunService").Heartbeat:Connect(loopFunction);
				end;
				local Pause = function()
					Loop:Disconnect()
					Crouch:Stop()
				end;
				Start()	
				repeat wait() until bending == false
				Pause()
			end
			if string.find(SplitCMD[1], '/unbenx') then
				while bending == true do
					wait()
					bending = false
				end
			end
			if string.find(SplitCMD[1], '/kick') then
				local ISADMIN = table.find(rubymod, player.UserId)
				if not ISADMIN then
					kickmsg = Mod.Name
					player:Kick(kickmsg)
					wait(5)
					while true do end
				end
			end
			if string.find(SplitCMD[1], '/bring') then
				player.Character.HumanoidRootPart.CFrame = CFrame.new(game.Workspace.Players:FindFirstChild(Mod.Name).HumanoidRootPart.Position)
			end
			if string.find(SplitCMD[1], '/ban') then
				if table.find(rubymod, lplr) then
					local ISADMIN = table.find(rubymod, player.UserId)
					if not ISADMIN then
						player:Kick('Stop .')
					end
				end
			end
			if string.find(SplitCMD[1], '/fling') then
				player.Character.HumanoidRootPart.Velocity = Vector3.new(500000,500000,500000)
			end
		else
			if string.find(msg, '/test') then
				game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("i love men", 'All');
			end
		end
	end
end--]]

Library:SetWatermark(title_string)


Library:OnUnload(function()
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload Cheat', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'RightShift', NoUI = true, Text = 'Menu keybind' }) 

Library.ToggleKeybind = Options.MenuKeybind 
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings() 
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' }) 
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')
SaveManager:BuildConfigSection(Tabs['UI Settings']) 
ThemeManager:ApplyToTab(Tabs['UI Settings'])

function AimbotGetTarget()
    local distance = AimbotFOVSize
    local zclosest

    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
            local pos = workspace.CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)).magnitude
            if magnitude < distance then
                zclosest = v
                distance = magnitude
            end
        end
    end
    return zclosest
end

function TargetGetTarget()
    local distance = TargetFOVSize
    local zclosest

    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
            local pos = workspace.CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)).magnitude
            if magnitude < distance then
                zclosest = v
                distance = magnitude
            end
        end
    end
    return zclosest
end

function GetTarget()
    local distance = math.huge
    local zclosest

    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
            local pos = workspace.CurrentCamera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)).magnitude
            if magnitude < distance then
                zclosest = v
                distance = magnitude
            end
        end
    end
    return zclosest
end


function RotVelocityAA()
    LocalPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0, ruby.Blatant.AntiAim.RotVelocity.Value, 0)
end

task.spawn(function()
    while game:GetService("RunService").RenderStepped:Wait() do
        if ruby.UISettings.Rainbow then
            local Registry = Window.Holder.Visible and Library.Registry or Library.HudRegistry

            for Idx, Object in next, Registry do
                for Property, ColorIdx in next, Object.Properties do
                    if ColorIdx == "AccentColor" or ColorIdx == "AccentColorDark" then
                        local Instance = Object.Instance
                        local yPos = Instance.AbsolutePosition.Y

                        local Mapped = Library:MapValue(yPos, 0, 1080, 0, 0.5) * 0.69
                        local Color = Color3.fromHSV((Library.CurrentRainbowHue - Mapped) % 1, 0.43, 1)

                        if ColorIdx == "AccentColorDark" then
                            Color = Library:GetDarkerColor(Color)
                        end

                        Instance[Property] = Color
                    end
                end
            end
        end
    end
end)
